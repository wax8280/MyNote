# Manifest文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent.activitytest">
  
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
      
    </application>
</manifest>
```

# 活动

## 活动基本用法

### 创建活动

一个活动如下所示

```java
public class FirstActivity extends AppCompatActivity {

    private static final String TAG = "FirstActivity";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);   //制定一个布局文件
        setContentView(R.layout.first_layout);   //绑定一个按键

        //你也可以隐藏标题栏
        if (getSupportActionBar() != null){
            getSupportActionBar().hide();
        }
}
```

### 布局文件

与活动同时创在有一个布局文件，其放在res/layout下

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/button_1"
        android:text="Button 1"
        />

    <!--在xml中定义id用@+id，引用的话用@id-->

</LinearLayout>
```

### 修改Manifest文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent.activitytest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".FirstActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
  
</manifest>
```

### 显示Toast

试试显示一个Toast。在`onCreate`函数里面

```java
...
        Button button1 = (Button) findViewById(R.id.button_1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
//                创造出一个Toast对象
//                context：上下文对象
//                text：文本内容
//                Toast显示时长


                Toast.makeText(FirstActivity.this, "You clicked", Toast.LENGTH_SHORT).show();
            }
        });
...
```

### 销毁活动

使用`finish()`销毁一个活动

```java
    protected void onCreate(Bundle savedInstanceState) {
        finish();
    }
```

## Intent

### 显式Intent

我们新建一个新的布局文件，新建一个新的活动，类名为`SecoendActivity`在其`onCreate()`函数里面初始化。

在第一个活动的`onCreate()`函数里面。

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(FirstActivity.this,SecondActivity.class);
                startActivity(intent);
            }
        });
```

通过`FirstActivity.this`传入一个`Context`。

### 隐式Intent

我们需要更改下manifest文件。增加一个activity标签。

```xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <!-- 当前活动可以响应com.example.activitytest.ACTION_START这个action -->
                <action android:name="com.example.activitytest.ACTION_START" />
                <!-- 指明了当前的活动能够响应的Intent中还可能带有的category -->
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
```

我们新建一个新的布局文件，新建一个新的活动，类名为`SecoendActivity`在其`onCreate()`函数里面初始化。

在第一个活动的`onCreate()`函数里面。

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent("com.example.activitytest.ACTION_START");
//                会将默认的category添加到Intent中
//                你也可以制定多个category
//                intent.addCategory("com.example.activitytest.MY_CATEGORY");
                startActivity(intent);
            }
        });
```

关于category：提供将要执行的action的额外信息，一般在隐式地启动activity时需要用到。

### 使用隐式Intent打开其他程序

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(Intent.ACTION_VIEW);
//                打电话
//                Intent intent=new Intent(Intent.ACTION_DIAL);
//                intent.setData(Uri.parse("tel:10086"));

                intent.setData(Uri.parse("http://www.baidu.com"));
                startActivity(intent);
            }
        });
```

我们也可以在`<intent-filter>`标签里面添加一个`<data>`来制定当前活动能够响应什么类型的数据。

### 向下一个活动传递数据

在第一个活动中传递

```java
//        利用intent传递数据到下一个activity
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String data = "Hello";
                Intent intent =new Intent(FirstActivity.this,SecondActivity.class);
                intent.putExtra("extra_data",data);
                startActivity(intent);
            }
        });
```

在第二个活动中接受

```java
        Intent intent=getIntent();
        String data=intent.getStringExtra("extra_data");
```

若我们需要向第二个活动发送数据之后等待其的回答。我们可以在一个活动中，将`startActivity(intent);`换成`startActivityForResult(intent,1);`

然后重载`AppCompatActivity`类的一个方法。

```java
//    接收从Activity中返回的数据
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode){
            case 1:
                if(resultCode==RESULT_OK){
                    String returnedData=data.getStringExtra("data_return");
                    Log.d(TAG, returnedData);
                }
                break;
            default:
        }
    }
```

我们在第二个活动里面

```java
//        返回数据给上一个Activity
        Button button2=(Button)findViewById(R.id.button_2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent();
                intent.putExtra("data_return","Hello");
                setResult(RESULT_OK,intent);
                finish();
            }
        });
```

## 活动的生命周期

### 返回栈

我们每启动一个新的活动，就会覆盖在原来的活动上面。就像数据结构里面的栈，我们称其为“返回栈”。

### 活动状态

* 活动状态：当一个活动位于返回栈的栈顶时，这时活动就在于运行状态。
* 暂停状态：当一个活动不再处于栈顶位置，但仍可见，此时活动就进入了暂停状态。
* 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候。
* 销毁状态：当一个活动从返回栈中移除后 。

### 活动的生存期

* onCreate()：在活动第一次被创建的时候调用。
* onStart()：在活动有不可见变为可见的时候调用。
* onResume()：在活动准备好和用户进行交互的时候调用。
* onPause()：在系统准备去启动或者恢复另一个活动的时候调用。这个方法一定要快。
* onStop()：在活动完全不可见的时候调用。和onPause()的区别在于。如果启动的新活动是一个对话框的活动，那么onPause()会执行，而onStop()不会执行。
* onDestory()：在活动被销毁之前调用。
* onRestart()：在活动头停止状态变为运行状态之前调用。

![](./static/activity.png)

## 活动的启动模式

我们在manifest文件下面修改启动模式。

```xml
        <activity 
            android:name=".FirstActivity"
            android:launchMode="standard"
            >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
```

### standard

在不指定的情况下，默认。

每当启动一个新的活动，他就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式启动的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。

### singleTop

当活动的启动模式指定为singleTop时，在启动活动时候如果发现返回栈已经是该活动，则认为可以直接使用它。不过如果活动并未处于栈顶的位置，还是会启动新的实例的。

### singleTask

每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在就直接使用，并且把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。

### singleInstance

活动会启用一个新的返回栈来管理这个活动。

## 关于活动的PS

### 知晓当前是在哪一个活动

```
getClass().getSimpleName()
```

### 随时退出程序

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<Activity>();

    public static void addActivity(Activity activity) {
        activities.add(activity);
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }
    
    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
    }
}
```

使用一个管理器，重写每个活动的onCreate和onDestory方法。

# UI
##常见控件
### TextView

```xml
<TextView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="this is text"
    android:gravity="center"
    />
```

* match_parent：当前空间的大小和父布局大小一样
* wrap_content：当前空间的大小刚好包含住里面的内容

可以同时用`|`来制定多个对齐方式

### Button

### EditText

```xml
    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="input somethings"
        android:maxLines="2"/>
```

### ImageView

```xml
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/ic_launcher_background"/>
```

### ProgressBar

```xml
    <ProgressBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
```

### AlertDialog

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);
dialog.setTitle("Title");
dialog.setMessage("Message");
dialog.setCancelable(false);
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        
    }
});

dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        
    }
});
dialog.show();
```

### ProgressDialog

```java
ProgressDialog progressDialog=new ProgressDialog(FirstActivity.this);
progressDialog.setTitle("Title");
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(true);
progressDialog.show();
```

## 可见与不可见

任何空间都可以用`android:visibility`设定。

* visible：可见
* invisible：不可见
* gone：不仅不可见，而且不占用屏幕空间

我们也可以在代码中

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setVisibility(View.VISIBLE);
```

## 四种布局

### LinearLayout

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="Button"/>

</LinearLayout>
```

我们可以设置`android:orientation="horizontal"`来将布局设置为水平布局。

我们可以设置`android:layout_gravity="center"`来控制控件的位置。有`top`，`bottom`，`center_horizontal`，`center_vertical`，`center`可选。

我们还可以按照比例设置，如下button与textview的比例为一比一。

```xml
    <Button
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"/>

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="this is text"
        android:layout_weight="1"/>
```

### RelativeLayout

### RelativeLayout

```xml
    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Hello World!"
            android:layout_alignParentLeft="true"
            android:layout_alignParentBottom="true"
            />

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Hello World2!"
            android:layout_alignParentTop="true"
            android:layout_alignParentRight="true"
            />
    </RelativeLayout>
```

![](./static/RelativeLayout.png)

上面的参数设置是相对于父布局的。若果你想相对于某一控件。

```xml
<RelativeLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent">
  <Button
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="Hello World!"
          android:id="@+id/Hello1"
          android:layout_centerInParent="true"
          />

  <Button
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:id="@+id/Hello2"
          android:layout_above="@id/Hello1"
          android:layout_toLeftOf="@id/Hello1"
          android:text="Hello World2!"
          />

  <Button
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:id="@+id/Hello3"
          android:layout_below="@id/Hello1"
          android:layout_toRightOf="@id/Hello1"
          android:text="Hello World3!"
          />
</RelativeLayout>
```

![](./static/RelativeLayout2.png)

此外，还有`android:layout_alignTop`，`android:layout_alignBottom`等，对齐某一控件的边缘。

```xml
<RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        android:id="@+id/Hello1"
        android:layout_centerInParent="true"
        />
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/Hello2"
        android:layout_alignRight="@id/Hello1"
        android:text="Hello World"
        />
</RelativeLayout>
```

![](./static/RelativeLayout3.png)

### FrameLayout

毫无布局可言，全部放在左上角

```xml
<FrameLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" 
        android:src="@drawable/ic_launcher_background"/>
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/Hello2"
        android:text="Hello World" />
</FrameLayout>
```

![](./static/FrameLayout.png)

### TableLayout

```xml
<TableLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TableRow>
        <TextView 
            android:layout_height="wrap_content"
            android:text="Account:"/>
        
        <EditText 
            android:layout_height="wrap_content"
            android:hint="Input your account"/>
    </TableRow>
    <TableRow>
        <TextView
            android:layout_height="wrap_content"
            android:text="Password:"/>

        <EditText
            android:layout_height="wrap_content"
            android:hint="Input your passowrd"/>
    </TableRow>
    
    <TableRow>
        <Button 
            android:layout_height="wrap_content"
            android:layout_span="2"
            android:text="Login"/>
    </TableRow>
</TableLayout>
```

`android:layout_span="2"`让登陆按钮占据两列的空间。

![](./static/TableLayout.png)

在TableLayout标签里加上`android:stretchColumns="1"`可以将不能占据满屏幕的控件的第二列进行拉伸。若0则第一列拉伸。

## 引入布局

若我们需要引入一个布局文件，只需要在xml文件中`<include layout="@layout/xml_files_name" />`即可，。

### 引入布局的绑定

若引用的布局里面需要绑定按钮等，那么每次引入布局都需要重新绑定，这不行。

假若我们需要引入的布局文件为`hello.xml`我们新建一个类，在类中绑定好所有按钮。

```java
public class HelloLayout extends LinearLayout {
    public HelloLayout(Context context, AttributeSet attrs){
        super(context, attrs);
        // 动态加载一个布局文件，第一个参数是需要加载的布局文件的id，第二个参数是给加载好的布局在添加一个父布局。
        LayoutInflater.from(context).inflate(R.layout.hello,this);
        Button hello=(Button) findViewById(R.id.hello);
        hello.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(getContext(),"Hello",Toast.LENGTH_SHORT).show();
            }
        });
    }
}
```



hello.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    android:layout_width="match_parent"
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_height="wrap_content">
    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello"
        android:id="@+id/hello"
        />
</LinearLayout>
```

在需要引入的地方

```xml
<com.example.vincent8280.myapplication.HelloLayout
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"></com.example.vincent8280.myapplication.HelloLayout>
```

## ListView

```java
public class MainActivity extends AppCompatActivity {
      private String[] data={"item1","item2","item1","item2","item1","item2","item1","item2",
              "item1","item2","item1","item2","item1","item2","item1","item2","item1","item2",
              "item1","item2","item1","item2"};
      @Override
      protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);

            ArrayAdapter<String> adapter=new ArrayAdapter<String>(
                    MainActivity.this,android.R.layout.simple_list_item_1,data
            );
            ListView listview =(ListView)findViewById(R.id.list_view);
            listview.setAdapter(adapter);
      }
}
```
`android.R.layout.simple_list_item_1`是一个内置的布局文件，里面有一个TextView，可以简单地显示一段文本。
```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.vincent8280.myapplication.MainActivity">

    <ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"></ListView>

</android.support.constraint.ConstraintLayout>
```

### 自定义Adapter

如果我们需要设置一个带图标的ListView，我们就需要自定义一个Adapter了。

活动的xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.vincent8280.myapplication.MainActivity">
    <ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">
    </ListView>
</android.support.constraint.ConstraintLayout>
```

我们再新建一个名为`image_list.xml`的layout。

```xml
<?xml version="1.0" encoding="utf-8"?>
    <LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:id="@+id/list_image"/>
        <TextView
            android:id="@+id/list_text"
            android:layout_width="match_parent"
            android:layout_height="match_parent"></TextView>

    </LinearLayout>
```

我们新建一个类，专门负责每一个listitem。在安卓中，资源都是以int形式出现的。

```java
public class ImageListItem {
    private String name;
    private int image_id;
    public ImageListItem(String name,int image_id){
        this.name=name;
        this.image_id =image_id;
    }

    public String get_name(){
        return this.name;
    }

    public int get_image_id(){
        return this.image_id;
    }
}
```

然后我们自定义一个Adapter

```java
public class ImageListAdapter extends ArrayAdapter<ImageListItem> {
    private int textViewResourceId;

    public ImageListAdapter(Context context, int textViewResourceId, List<ImageListItem> objects){
        super(context,textViewResourceId,objects);
        this.textViewResourceId=textViewResourceId;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ImageListItem image_list_item=getItem(position); //从this.objects里面获取当前项的Fruit实例。position代表第几个list，从0开始。
        View view= LayoutInflater.from(getContext()).inflate(this.textViewResourceId,null);
        ImageView image=(ImageView) view.findViewById(R.id.list_image);
        TextView name=(TextView) view.findViewById(R.id.list_text);
        image.setImageResource(image_list_item.get_image_id());
        name.setText(image_list_item.get_name());
        return view;
    }
}
```

`textViewResourceId`代表`image_list.xml`这个layout。`objects`代表每一个listitem项的实例的列表。

活动类

```java
public class MainActivity extends AppCompatActivity {
      private List<ImageListItem> data=new ArrayList<ImageListItem>();

      @Override
      protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            init();
            ImageListAdapter adapter=new ImageListAdapter(
                    MainActivity.this,R.layout.image_list,data
            );
            ListView listview =(ListView)findViewById(R.id.list_view);
            listview.setAdapter(adapter);
      }

      private void init(){
            data.add(new ImageListItem("item1",R.drawable.ic_launcher_background));
            data.add(new ImageListItem("item2",R.drawable.ic_launcher_background));
            data.add(new ImageListItem("item3",R.drawable.ic_launcher_background));
            data.add(new ImageListItem("item4",R.drawable.ic_launcher_background));
      }
}
```

我们注意到，`getView()`每次都将布局重新加载一遍，这会导致性能低下。我们可以使用`convertView`参数，用于将之前加载好的布局进行缓存。

```java
if (convertView==null){
    view= LayoutInflater.from(getContext()).inflate(this.textViewResourceId,null);
}else{
    view=convertView;
}
```

我们还可以使用`ViewHolder`来缓存控件的实例。`ViewHolder`使我们自己编写的类，之后调用`view.setTag()`方法将这个类保存在`view`中。

```java
class ViewHolder{
    ImageView image_view;
    TextView text_view;
}

@Override
public View getView(int position, View convertView, ViewGroup parent) {
    ImageListItem image_list_item=getItem(position); //从this.objects里面获取当前项的Fruit实例。position代表第几个list，从0开始。
    View view;
    ViewHolder view_holder;
    if (convertView==null){
        view= LayoutInflater.from(getContext()).inflate(this.textViewResourceId,null);
        view_holder=new ViewHolder();
        view_holder.image_view=(ImageView) view.findViewById(R.id.list_image);
        view_holder.text_view=(TextView) view.findViewById(R.id.list_text);
        view.setTag(view_holder);   //将ViewHolder存储在View中
    }else{
        view=convertView;
        view_holder=(ViewHolder) view.getTag();
    }
    view_holder.image_view.setImageResource(image_list_item.get_image_id());
    view_holder.text_view.setText(image_list_item.get_name());
    return view;
}
```

## 单位与尺寸

不同于px与pt安卓使用dp和sp，使得在不同密度的屏幕中显示比例保持一致。sp用于文字大小。

# 碎片

我们先新建`left_fragment.xml`和`right_fragment.xml`文件。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/list_text"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="Hello World!left"></TextView>

</LinearLayout>
```

然后依次新建两个类。

```java
public class LeftFragment extends Fragment{
//      继承android.app.Fragment。另一个包的那个是为了兼容4.0以下系统的。
      @Nullable
      @Override
      public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
            View view=inflater.inflate(R.layout.left_fragment,container,false);
            return view;
      }
}
```

接着改变下活动xml的代码。

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.vincent8280.myapplication.MainActivity">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <fragment
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="match_parent"
            android:id="@+id/left_fragment"
            android:name="com.example.vincent8280.myapplication.LeftFragment"/>

        <fragment
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="match_parent"
            android:id="@+id/right_fragment"
            android:name="com.example.vincent8280.myapplication.RightFragment"/>

    </LinearLayout>

</android.support.constraint.ConstraintLayout>
```

## 动态添加碎片

我们像上面那样，再新建一个layout，名为another_right_fragment.xml。然后也类似的新建一个类。

修改活动xml文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.constraint.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.vincent8280.myapplication.MainActivity">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent">
        <fragment
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="match_parent"
            android:id="@+id/left_fragment"
            android:name="com.example.vincent8280.myapplication.LeftFragment"/>
        
        <FrameLayout
            android:layout_width="0dp"
            android:layout_weight="1"
            android:id="@+id/right_layout"
            android:layout_height="match_parent">
            <fragment
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:id="@+id/right_fragment"
                android:name="com.example.vincent8280.myapplication.RightFragment"/>
        </FrameLayout>

    </LinearLayout>

</android.support.constraint.ConstraintLayout>
```

FrameLayout布局没有布局可言，只把所有元素放在左上角。

我们可以动态加载碎片了

```java
public class MainActivity extends AppCompatActivity {
      @Override
      protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            AnotherRightFragment fragment=new AnotherRightFragment();
            FragmentManager fragmentManager=getFragmentManager();
            FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction();
            fragmentTransaction.replace(R.id.right_layout,fragment);
            fragmentTransaction.commit();
      }
}
```

## 在碎片中模拟返回栈

上面的例子，如果按下Back键会直接退出。怎么样才能按下Back回到上一个碎片呢？

在`fragmentTransaction.commit();`之前加上一行代码`fragmentTransaction.addToBackStack(null);`即可。

## 碎片与活动之间进行通信

FragmentManager提供了一个类似于findViewById的方法，专门用于从布局文件中获取碎片的实例。

```java
RightFragment rightFragment=(RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment); 
```

我们还可以动态获取活动

```
MainActivity activity=(MainActivity) getActivity();   //获取来的是一个context
```

## 碎片的生命周期

### 碎片的状态

* 运行状态：可见，并且它所关联的活动正处于运行状态时。

* 暂停状态：由于一个未占满屏幕的活动被添加到了栈顶。

* 停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态。或者通过调用 FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但有在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。

* 销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用 addToBackStack()方法，这时的碎片也会进入到销毁状态。 

### 碎片的回调方法 

Fragment类提供了一系列的回调方法，以覆盖碎片的每个环节，主要的回调方法有：  

* onAttach()：当碎片和活动建立关联的时候调用。 
* onCreateView()：为碎片创建视图（加载布局）时调用。 
* onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕的时候调用。
* onDestroyView()：当与碎片关联的视图被移除的时候调用。 
* onDetach()：当碎片和活动解除关联的时候调用。

![](./static/fragment_lift.png)

## 使用限定符

很多平板应用采用都是双页模式(程序在左侧的面板上显示一个包含子项的列表，在右侧的面板上显示内容)，因为平板电脑放的屏幕足够大，完全可以同时显示下两页的内容，但手机屏幕一次就只能显示一页的内容，因此两个页面需要分开显示    我们需要借助“限定符(Qualifiers)”来在运行时判断程序是应该使用双页模式还是单页模式。

我们可以在res目录下新建一个“限定符-layout”的文件夹。例如我们的活动文件为activity_main.xml，我们需要在平板上使用另一个碎片，我们即可创建一个`large-layout`文件夹，然后在里面重新新建一个activity_main.xml。

| **限定符** | **描述**        |
| ------- | ------------- |
| small   | 小             |
| normal  | 中             |
| large   | 大             |
| xlarge  | 超大            |
| ldpi    | <120dpi       |
| mdpi    | 120dpi~160dpi |
| hdpi    | 160dpi~240dpi |
| xhdpi   | 240dpi~320dpi |
| land    | 横屏设备          |
| port    | 竖屏设备          |

除了上面的限定符之外，我们可以使用诸如`layout-sw600dp`之类的文件夹，在程序运行在宽度大于600dp的设备上，会加载里面的文件。

# 广播机制

广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播作为Android组件间的通信方式，可以使用的场景如下：
1.同一app内部的同一组件内的消息通信（单个或多个线程之间）；

2.同一app内部的不同组件之间的消息通信（单个进程）；

3.同一app具有多个进程的不同组件之间的消息通信；

4.不同app之间的组件之间消息通信；

5.Android系统在特定情况下与App之间的消息通信。



普通广播 (Normal broadcast)

* 所有监听该广播接受者都可以监听到该广播

* 同级别接收先后顺序是随机的(无序)

* 级别低的后收到广播

* 接收器不能截断广播的继续传播，也不能处理广播

* 同级别动态注册高于静态注册

有序广播 (Oredered broadcast)

* 按照接收者的优先顺序来接收广播，优先级别在intent-filter中的priority中声明，-1000到1000之间，值越大优先级越高，可以终止广播的继续传播，接受者可以修改intent的内容。
* 同级别接收顺序是随机的
* 级别低的后收到
* 能截断广播的继续传播，高级别的广播接收器接收广播后能决定时候截断。
* 能处理广播同级别动态注册高于静态注册

## 动态注册与静态注册

在代码中注册为动态注册，在AndroidManifest.xml中注册为动态注册。

### 动态注册

```java
public class MainActivity extends AppCompatActivity {
      private IntentFilter intentFilter;
      private MyBroadcastReceiver myBroadcastReceiver;

      @Override
      protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            intentFilter=new IntentFilter();
            //当网络发生变化时，系统发出这样一条广播
            intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
            myBroadcastReceiver=new MyBroadcastReceiver();
            registerReceiver(myBroadcastReceiver,intentFilter);
      }

      @Override
      protected void onDestroy() {
            super.onDestroy();
            unregisterReceiver(myBroadcastReceiver);
      }

      class MyBroadcastReceiver extends BroadcastReceiver {
            @Override
            public void onReceive(Context context, Intent intent) {
                  ConnectivityManager connectivityManager=(ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
                  NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();
                  String Text;
                  if (networkInfo!=null && networkInfo.isAvailable()){
                        Text="network is available";
                  }else{
                        Text="network is unavailable";
                  }

                  Toast.makeText(context,Text,Toast.LENGTH_SHORT).show();
            }
      }
}
```

最后我们还要声明权限

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent8280.myapplication" >
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" >
        <activity android:name=".MainActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

### 静态注册

希望程序在未启动的情况下接受到广播

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent8280.myapplication" >
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <!--监听系统开机权限的广播-->
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme" >
        <activity android:name=".MainActivity" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <receiver android:name=".BootCompleteRecevier">
            <intent-filter>
                <!--需要接受的广播-->
                <!--BOOT_COMPLETED是系统启动后发出的一条广播-->
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
            </intent-filter>
        </receiver>
    </application>

</manifest>
```

BroadReceiver生命周期只有十秒左右，不能直接执行耗时操作，不然会出现ANR(应用程序无响应)，也不能用子线程来做，因为每次广播来的时候都会创建一个Reveiver对象，并且调用onReceiver，执行完之后 ，对象会立刻被销毁，子线程也没了要做耗时操作的话，应该通过发送Intent给Service，由Service来完成。 

动态注册广播接受者的话要在Destory回调事件进行unregister。

## 发送自定义广播

### 发送标准广播

```java
Intent intent=new Intent("com.example.vincent8280.myapplication.MY_BROADCAST");
sendBroadcast(intent);
```

### 发送有序广播

```java
Intent intent=new Intent("com.example.vincent8280.myapplication.MY_BROADCAST");
sendOrderedBroadcast(intent,null);
```

第二个参数是与权限有关的参数。

在`BroadcastReceiver`里面可以使用`abortBroadcast()`将广播截断。

```xml
<receiver android:name=".BootCompleteRecevier">
    <!--有序广播的优先级越高，越先接收到-->
    <intent-filter android:priority="100">
        <action android:name="android.intent.action.BOOT_COMPLETED"/>
    </intent-filter>
</receiver>
```

## 本地广播

只在应用程序内部进行传递。本地广播是无法通过静态注册的方法接收的。

```java
private LocalReceiver localReceiver;
private LocalBroadcastManager localBroadcastManager;

class LocalReceiver extends BroadcastReceiver{
      @Override
      public void onReceive(Context context, Intent intent) {
            // do somethings
      }
}
...
localBroadcastManager=LocalBroadcastManager.getInstance(this);    //获取实例

...
//发送
Intent intent=new Intent("com.example.vincent8280.myapplication.LOCAL_BROADCAST");
localBroadcastManager.sendBroadcast(intent);    //发送本地广播
...

//注册本地广播监听
intentFilter=new IntentFilter();
intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
localReceiver=new LocalReceiver();
localBroadcastManager.registerReceiver(localReceiver,intentFilter);
```

记得在`onDestory`方法里面注销注册的广播。

# 持久化

## 文件存储

`openFileOutput`，第一个参数指定文件名，目录默认存储在`/data/data/<package_name>/files/`目录下。第二个参数是操作模式，`MODE_PRIVATE`是默认的操作模式，相当于python的w模式，而`MODE_APPEDN`相当于python的a模式。

```java
String data = "Hello";
FileOutputStream fileOutputStream = null;
BufferedWriter bufferedWriter = null;
try {
      fileOutputStream = openFileOutput("data", Context.MODE_PRIVATE);
      bufferedWriter = new BufferedWriter(new OutputStreamWriter(fileOutputStream));
      bufferedWriter.write(data);
} catch (IOException e) {
      e.printStackTrace();
} finally {
      try {
            if (bufferedWriter != null) {
                  bufferedWriter.close();
            }
      } catch (IOException e) {
            e.printStackTrace();
      }
}
```

## SharedPreferences存储

SharedPreferences存储是利用键值对的方式来存储的，感觉有点类似map集合

要使用该方法来存储数据就要先**获得一个SharedPreferences对象**，有三种获取方法

* Context上下文类中的getSharedPreferences
  两个参数，第一个是指定文件的名称，不在就创建。目录也是在data/data/包名/shared_prefs目录下
  第二个参数是操作模式。MODE_PRIVATE是默认的，只允许当前的应用程序对其进行操作,MODE_MULTI_PROCESS是一般用于有多个进程中对同一个SharedPreferences文件进行读写的情况,同样有MODE_WORLD_WRITEABLE MODE_WORLD_READABLE两个被废弃的模式
* Activity类中的getPreferences
  只有一个参数，也是操作模式，文件的名称是默认的当前活动的类名
* PreferenceManager管理类中的getDefaultSharedPreferences()
  管理类中的一个静态方法，接收一个context参数,自动把当前的包名作为文件命名的前缀

   SharedPreferences  pref=getSharedPreferences( "data", MODE_PRIVATE);
  ​           

```java
//写
SharedPreferences.Editor editor=getSharedPreferences( "data", MODE_PRIVATE).edit();
editor.putString( "name", "hl174");
editor.putInt( "age", 18);
editor.putBoolean( "吃饭没", false );
editor.commit();

editor.clear();		//将文件中的所有数据清除掉

//读
String name= pref.getString( "name", "");
int age= pref.getInt( "age", 0);
boolean lunch= pref.getBoolean( "吃饭没", false );
```
## SQLite

为方便管理数据库有一个专门的抽象类`SQLiteOpenHelper`,它有两个抽象的方法`onCreate()`和`onUpdate()`。此外还有两个实例方法，`getReadableDatabase()`和`getWritableDatabase()`,都可以创建或者是打开一个现有的数据库（存在就打开，不在就创建），返回一个可对数据库进行操作的对象。当数据库不可写入的时候，前者返回的是一个只能读的方式打开数据库，后者则会出现异常数据库文件同样还是会放在`data/data/包名/databases`下面。

### 创建

一般步骤：
* 构建SQLiteOpenHelper的实例，也就是完成其构造函数(参数一是context，第二个是要创建的数据库的名字，第三个是cursor,一般是null,第四个是数据库的版本号)
* 再调用getReadableDatabase()或者getWritableDatabase()方法创建数据库
* 同时重写onCreate()方法，该方法也会得到执行

```java
public class MyDatabaseHelper extends SQLiteOpenHelper {
      /*
      补充一下建表的一些类型
      integer ---整型
      real-----浮点类型
      text---文本类型
      blob---二进制类型
      
      */
      public static final String CREATE_BOOK = "create table book(id integer primary key autoincrement,"
              + "author text"
              + "price real"
              + "pages integer"
              + "name text)";
      private Context mContext;

      public MyDatabaseHelper(Context context, String name,
                              CursorFactory factory, int version) {
            super(context, name, factory, version);
            mContext = context;
      }

      @Override
      public void onCreate(SQLiteDatabase db) {
            //执行建表语句
            db.execSQL(CREATE_BOOK);
            Toast.makeText(mContext, "数据库创建成功", Toast.LENGTH_SHORT).show();
      }

      @Override
      public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      }
}
```

在主活动里面

```java
dbHelper= new MyDatabaseHelper( this, "BookStore.db", null, 1)
dbHelper. getWritableDatabase();  
```

当传入的版本号大于上一次的版本号的时候，会执行`onUpgrade`方法。

### 插入

关于CRUD操作，由于之前用到了getWritableDatabase或者是getReadableDatabase方法，这两个方法可以返回一个SQLiteDatabase对象，通过这个对象就可以操作数据库该对象有一个Insert()方法，接收三个参数：第一个是表名，第二个是给未指定添加数据的情况下某些可为空的列赋null，第三个是ContentValue对象，该对象里面有一系列的get put方法，有点类似于SharedPreferences里面的的构造参数的方法。

```java
SQLiteDatabase dbOperate= dbHelper.getWritableDatabase();
ContentValues values= new ContentValues();
//下面没有给表中的id赋值，因为在建表的时候，id是默认自动增长的
//添加第一条记录到Book
values.put( "name", "安卓入门之路" );
values.put( "author", "hl174");
values.put( "pages", 800);
values.put( "price", 50);               
dbOperate.insert( "book", null, values);

values.clear();

//插入第二条记录到book
values.put( "name", "安卓精通" );
values.put( "author", "hl174");
values.put( "pages", 700);
values.put( "price", 45);     
dbOperate.insert( "book", null, values);
```

### 更新数据

//更新数据

```java
 Button updateData=(Button) findViewById(R.id. update_data);
  updateData.setOnClickListener( new OnClickListener() {
        @Override
        public void onClick(View v) {
             // TODO Auto-generated method stub
            SQLiteDatabase db= dbHelper.getWritableDatabase();
            ContentValues values= new ContentValues();
             values.put( "price", 10000);
            
    db.update( "book", values, "name=?", new String[]{"安卓入门之路" });
       }
 });
```
### 删除

```java
 Button deleteData=(Button) findViewById(R.id. delete_data);
  deleteData.setOnClickListener( new OnClickListener() {      
        @Override
        public void onClick(View v) {
             // TODO Auto-generated method stub
            SQLiteDatabase db= dbHelper.getWritableDatabase();
             //删除页数大于500的记录
             db.delete( "book", "pages>?", new String[]{"500" });
       }
 });
```
### 查询

`public Cursor query (String table, String[] columns, String selection, String[]selectionArgs, String groupBy, String having, String orderBy)`

| table         | The table name to compile the query against. |
| ------------- | ---------------------------------------- |
| columns       | 查询的列名                                    |
| selection     | WHERE的约束                                 |
| selectionArgs | WHERE中占位符提供具体的值                          |
| groupBy       | 指定需要GROUP BY的列                           |
| having        | 对GROUP BY后的结果进一步约束                       |
| orderBy       | 排序                                       |

```java
public void onClick(View v) {
      SQLiteDatabase db = dbHelper.getWritableDatabase();
      //查询book表中的所有数据
      Cursor cursor = db.query("book", null, null, null, null, null, null);
      if (cursor.moveToFirst()) {
            do {
                  //遍历cursor对象，取出数据并打印
                  String name = cursor.getString(cursor.getColumnIndex("name"));
                  String author = cursor.getString(cursor.getColumnIndex("author"));
                  int pages = cursor.getInt(cursor.getColumnIndex("pages"));
                  double price = cursor.getDouble(cursor.getColumnIndex("price"));

            } while (cursor.moveToNext());
      }
      cursor.close();
}
```

首先是通过db.query得到cursor对象，在cursor类中我们发现了下面的一些方法，getString,getDouble,getInt等但是都需要传一个参数进去，也就是所在列的下标，从0开始计数。
要得到相应列所在的下标同样有方法getColumnIndex(String columnName),这样的话先得到列所在的下标，然后通过该下标得到相应的记录值

### 事务

```java
db.beginTransaction(); //循环之前开启事务
db.setTransactionSuccessful(); //循环结束后调用
db.endTransaction();//最后释放事务
```

# 内容提供器

内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能， 它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据 的安全性。目前，使用内容提供器是 Android 实现跨程序共享数据的标准方式。

## 访问其他程序中的数据

### ContentResolver 的基本用法
ContentResolver 中提供了一系列的方法用于对数据进行 CRUD 操作，其中 insert()方法用于 添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。

不同于 SQLiteDatabase，ContentResolver 中的增删改查方法都是不接收表名参数的，而是使用一个 Uri 参数代替，这个参数被称为内容 URI。

内容 URI 给内容提供器中的数据建立

 了唯一标识符，它主要由两部分组成，权限（authority）和路径（path）。权限是用于对不同 的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个 程序的包名是 com.example.app ，那么该程序对应的权限就可以命名为 com.example.app. provider。路径则是用于对同一应用程序中不同的表做区分的，通常都会添加到权限的后面。比如某个程序的数据库里存在两张表，table1 和 table2，这时就可以将路径分别命名为/table1 和/table2，然后把权限和路径进行组合，内容 URI 就变成了 com.example.app.provider/table1 和 com.example.app.provider/table2。

内容 URI 最标准的格式写法如下：

`content://com.example.app.provider/table1`
`content://com.example.app.provider/table2`

```java
Uri uri = Uri.parse("content://com.example.app.provider/table1")
Cursor cursor = getContentResolver().query(
        uri,
        projection, 
        selection, 
        selectionArgs, 
        sortOrder);
```
| query()方法参数   | 对应 SQL部分                  | 描述                  |
| ------------- | ------------------------- | ------------------- |
| uri           | from table_name           | 指定查询某个应用程序下的某一张表    |
| projection    | select column1, column2   | 指定查询的列名             |
| selection     | where column = value      | 指定 where 的约束条件      |
| selectionArgs | -                         | 为 where 中的占位符提供具体的值 |
| orderBy       | order by column1, column2 | 指定查询结果的排序方式         |

查询完成后返回的仍然是一个 Cursor 对象。

```java
if(cursor!=null){
      while(cursor.moveToNext()){
            String column1=cursor.getString(cursor.getColumnIndex("column1"));
            int column2=cursor.getInt(cursor.getColumnIndex("column2"));
      }
      cursor.close();
}
```

插入

```java
ContentValues values = new ContentValues();
values.put("column1","text");
values.put("column2",1);
getContentResolver().insert(uri,values);
```

更新

```java
ContentValues values = new ContentValues();
values.put("column1","");
getContentResolver().update(uri,values,"column1 = ? and column2 = ?",new String[]{"text","1"});
```

删除

```java
getContentResolver().delete(uri, "column2 = ?", new String[] { "1" });
```
## 创建自己的内容提供器

```java
public class MyProvider extends ContentProvider {
      @Override
      public boolean onCreate() {
            return false;
      }

      @Nullable
      @Override
      public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
            return null;
      }

      @Nullable
      @Override
      public String getType(@NonNull Uri uri) {
            return null;
      }

      @Nullable
      @Override
      public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
            return null;
      }

      @Override
      public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
            return 0;
      }

      @Override
      public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
            return 0;
      }
}
```

`onCreate()`方法
在初始化内容提供器的时候调用。通常在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false则表示失败。注意，只有当存在ContentResolver尝试访问当前程序的数据时，内容提供器才会被初始化。

`getType()`方法

`content://com.example.demo.provider/table1/1`表示调用者想要访问table1表中id为1的数据
内容Uri的格式主要分为上面两种，以路径结尾的Uri表示想要访问该表中所有的数据，以id结尾就表示想要访问该表中相应id的数据。我们可以使用通配符的方式来分别匹配这两种格式的Uri
* *:表示匹配任意长的任意字符
* \#:表示匹配任意长度的数字

`content://com.example.demo.provider/*`匹配任意表的内容Uri格式
` content://com.example.demo.provider/table1/#`表中任意一行数据的

```java
private static final int TABLE1_DIR = 0;
    private static final int TABLE1_ITEM = 1;
    private static final int TABLE2_DIR = 3;
    private static final int TABLE2_ITEM = 4;
    private static UriMatcher matcher = null;

    static {
        matcher = new UriMatcher(UriMatcher.NO_MATCH);
        matcher.addURI("com.example.pby.demo.provider", "table1", TABLE1_DIR);
        matcher.addURI("com.example.pby.demo.provider", "table1/#", TABLE1_ITEM);
        matcher.addURI("com.example.pby.demo.provider", "table2", TABLE2_DIR);
        matcher.addURI("com.example.pby.demo.provider", "table2/#", TABLE1_ITEM);
    }


    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        switch (matcher.match(uri)) {
            //查询table1表中的所有数据
            case TABLE1_DIR: {
                break;
            }
            //查询table1表中的某一条数据
            case TABLE1_ITEM: {
                break;
            }
            //查询table2表中的所有数据
            case TABLE2_DIR: {
                break;
            }
            //查询table2表中的某一条数据
            case TABLE2_ITEM: {
                break;
            }
        }
        return null;
    }
```

getType()方法。它是所有的内容提供器都必须提供的方法，用于获取Uri对象对应的MIME类型。
一个内容URI所对应的MIME字符串主要由3部分组成，Android对这3个部分做了如下格式规定：
* 必须以vnd开头。
* 如果URI以路径结尾，则后接android.cursor.dir/；如果是以id结尾，则后接android.cursor.item/
* 最后接上vnd.<authority>.<path>

`content://com.example.pby.demo.provider/table1`这个内容Uri对应的MIME类型`vnd.android.cursor.dir/vnd.com.example.pby.demo.provider.table1`
`content://com.example.pby.demo.provider/table1/1`对应`vnd.android.cursor.item/vnd.com.example.pby.demo.provider.table1`

```java
@Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch(matcher.match(uri))
        {
            case TABLE1_DIR:
            {
                return "vnd.android.cursor.dir/vnd.com.example.pby.demo.provider.table1";
            }
            case TABLE1_ITEM:
            {
                return "vnd.android.cursor.item/vnd.com.example.pby.demo.provider.table1";
            }
            case TABLE2_DIR:
            {
                return "vnd.android.cursor.dir/vnd.com.example.pby.demo.provider.table2";
            }
            case TABLE2_ITEM:
            {
                return "vnd.android.cursor.item/vnd.com.example.pby.demo.provider.table2";
            }
        }
        return null;
    }
```

## 实现跨程序数据共享

我们把上面的`MyProvider`类编写完成。无非是在`update`或`query`等方法查询数据库并返回。

```java
public class MyProvider extends ContentProvider {
    private static final int PHONETABLE_DIR = 0;
    private static final int PHONETABLE_ITEM = 1;
    private static final String AUTHORITY = "com.example.android_demo.provider";
    private static UriMatcher matcher = null;
    private MySQLiteHelper sqliteHelper = null;

    static {
        matcher = new UriMatcher(UriMatcher.NO_MATCH);
        matcher.addURI("com.example.android_demo.provider", "phoneTable", PHONETABLE_DIR);
        matcher.addURI("com.example.android_demo.provider", "phoneTable/#", PHONETABLE_ITEM);
    }

    @Override
    public boolean onCreate() {
        sqliteHelper = new MySQLiteHelper(getContext(), "dataBase", null, 1);
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        Cursor cursor = null;
        SQLiteDatabase dataBase = sqliteHelper.getReadableDatabase();
        try {
            switch (matcher.match(uri)) {
                case PHONETABLE_DIR: {
                    cursor = dataBase.query("phoneTable", projection, selection, selectionArgs, null,null,sortOrder);
                    break;
                }
                case PHONETABLE_ITEM: {
                    //getPathSegments()方法，它会将内容URI权限之后的部分(也就是authority之后)进行分割，并把分割后
                    //的结果放入到一个字符创列表中去，0表示存放的路径--path,1表示的path之后的id
                    String id = uri.getPathSegments().get(1);
                    cursor = dataBase.query("phoneTable", projection, "id = ?", new String[]{id}, null, null, sortOrder);
                    break;
                }
            }
        } catch (Exception e) {

        } finally {
        }
        return cursor;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch(matcher.match(uri))
        {
            case PHONETABLE_DIR:
            {
                return "vnd.android.cursor.dir/vnd.com.example.android_demo.provider.phoneTable";
            }
            case PHONETABLE_ITEM:
            {
                return "vnd.android.cursor.item/vnd.example.android_demo.provider.phoneTable";
            }
        }
        return null;
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        SQLiteDatabase dataBase = sqliteHelper.getWritableDatabase();
        long newId = dataBase.insert("phoneTable", null, values);
        Uri returnUri = Uri.parse("content://" + AUTHORITY + "/phoneTable/" + newId);
        return returnUri;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
        int deleteRowsNumber = 0;
        SQLiteDatabase dataBase = sqliteHelper.getWritableDatabase();
        deleteRowsNumber = dataBase.delete("phoneTable", selection, selectionArgs);
        return deleteRowsNumber;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
        int updateRowNumber = 0;
        SQLiteDatabase dataBase = sqliteHelper.getWritableDatabase();
        updateRowNumber = dataBase.update("phoneTable", values, selection, selectionArgs);
        return updateRowNumber;
    }
}
```

我们的主活动代码就不写了，跟前面的差不多。

最后要记得在`AndroidManifest.xml`文件里面的`<application>`里面加上

```
<provider
android:name=".provider.MyProvider"
        android:authorities="com.example.android_demo.provider"
        android:enabled="true"
        android:exported="true">
</provider>
```

# 线程

## 线程的基本用法

```java
class MyThread extends Thread {

      @Override
      public void run() {
            // 处理具体的逻辑 
      }

}
//启动
new MyThread().start();
```

```java
class MyThread implements Runnable {
      @Override
      public void run() {
            // 处理具体的逻辑 
      }
}
//启动
MyThread myThread = new MyThread();
new Thread(myThread).start();
```

```java
new Thread(new Runnable() {
      @Override 
      public void run() {
            // 处理具体的逻辑 
        }
        
}).start();
```

## 在子线程中更新UI

安卓更新UI元素必须在主线程中，否则就会出现异常。一种常用的处理方法就是，在子线程中进行耗时操作，完成之后发送消息，通知主线程更新UI。

我们在主活动里面新增一个`Handler`对象并且重写了父类`handleMessage`方法，对具体的`Message`进行处理。

```java
private Handler mHandler = new Handler() {  
        @Override  
        public void handleMessage(Message msg) {  
            super.handleMessage(msg);  
            switch (msg.what) {  
            case 0:  
                //完成主界面更新,拿到数据 
                String data = (String)msg.obj;  
                // 更新UI
                textView.setText(data);  
                break;  
            default:  
                break;  
            }  
        }
};
```
然后我们在子进程里面向我们定义的`handle`发送一个`message`。
```java
 new Thread(new Runnable(){
      @Override 
      public void run(){
            //耗时操作，完成之后发送消息给Handler，完成UI更新
            //需要数据传递，用下面方法
            Message msg = new Message();
            msg.obj = "数据";    //可以是基本类型，可以是对象，可以是List、map等
            msg.what = 0
            mHandler.sendMessage(msg);
      }
}).start();  
```

## 解析异步消息处理机制

安卓中的异步消息处理主要有四个部分组成：Message、Handler、MessageQueue、Looper
* Message：Message是在线程之间传递的消息，它可以携带少量的信息，用于在不同线程之间交换数据。可以携带what字段、使用arg1和arg2字段来携带一些整形数据、使用obj字段携带一个Object对象。
* Handler：主要用于发送和处理消息。发送消息使用Handler的sendMessage()方法；发出的消息经过处理后，最终会传递到Handler的handleMessage()方法中。
* MessageQueue：主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息对列中，等待被处理。每个线程中只会有一个MessageQueue对象。
* Looper：Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中也只有一个Looper对象。

![](./static/message.jpg)

* 首先在主线程中创建一个`Handle`对象，重写`handleMessage()`方法。
* 然后当子线程中需要进行UI操作时就创建一个`Handler`对象，并通过`Handle`将这条消息发送出去。
* 之后这条消息会被添加到`MessageQueue`队列中等待处理。而`Looper`则会一直尝试从`MessageQueue`队列中取出待处理消息。
* 最后分发回`Handle`的`handleMessage()`方法中。由于`Handle`是在主线程中创建的，所以此时`handleMessage()`方法中的代码也会在主线程中运行。

# 服务

它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。

实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程中。




