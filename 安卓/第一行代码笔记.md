# Manifest文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent.activitytest">
  
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
      
    </application>
</manifest>
```

# 活动

## 活动基本用法

### 创建活动

一个活动如下所示

```java
public class FirstActivity extends AppCompatActivity {

    private static final String TAG = "FirstActivity";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);   //制定一个布局文件
        setContentView(R.layout.first_layout);   //绑定一个按键

        //你也可以隐藏标题栏
        if (getSupportActionBar() != null){
            getSupportActionBar().hide();
        }
}
```

### 布局文件

与活动同时创在有一个布局文件，其放在res/layout下

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/button_1"
        android:text="Button 1"
        />

    <!--在xml中定义id用@+id，引用的话用@id-->

</LinearLayout>
```

### 修改Manifest文件

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.vincent.activitytest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".FirstActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
  
</manifest>
```

### 显示Toast

试试显示一个Toast。在`onCreate`函数里面

```java
...
        Button button1 = (Button) findViewById(R.id.button_1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
//                创造出一个Toast对象
//                context：上下文对象
//                text：文本内容
//                Toast显示时长


                Toast.makeText(FirstActivity.this, "You clicked", Toast.LENGTH_SHORT).show();
            }
        });
...
```

### 销毁活动

使用`finish()`销毁一个活动

```java
    protected void onCreate(Bundle savedInstanceState) {
        finish();
    }
```

## Intent

### 显式Intent

我们新建一个新的布局文件，新建一个新的活动，类名为`SecoendActivity`在其`onCreate()`函数里面初始化。

在第一个活动的`onCreate()`函数里面。

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(FirstActivity.this,SecondActivity.class);
                startActivity(intent);
            }
        });
```

通过`FirstActivity.this`传入一个`Context`。

### 隐式Intent

我们需要更改下manifest文件。增加一个activity标签。

```xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <!-- 当前活动可以响应com.example.activitytest.ACTION_START这个action -->
                <action android:name="com.example.activitytest.ACTION_START" />
                <!-- 指明了当前的活动能够响应的Intent中还可能带有的category -->
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
```

我们新建一个新的布局文件，新建一个新的活动，类名为`SecoendActivity`在其`onCreate()`函数里面初始化。

在第一个活动的`onCreate()`函数里面。

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent("com.example.activitytest.ACTION_START");
//                会将默认的category添加到Intent中
//                你也可以制定多个category
//                intent.addCategory("com.example.activitytest.MY_CATEGORY");
                startActivity(intent);
            }
        });
```

关于category：提供将要执行的action的额外信息，一般在隐式地启动activity时需要用到。

### 使用隐式Intent打开其他程序

```java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(Intent.ACTION_VIEW);
//                打电话
//                Intent intent=new Intent(Intent.ACTION_DIAL);
//                intent.setData(Uri.parse("tel:10086"));

                intent.setData(Uri.parse("http://www.baidu.com"));
                startActivity(intent);
            }
        });
```

我们也可以在`<intent-filter>`标签里面添加一个`<data>`来制定当前活动能够响应什么类型的数据。

### 向下一个活动传递数据

在第一个活动中传递

```java
//        利用intent传递数据到下一个activity
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String data = "Hello";
                Intent intent =new Intent(FirstActivity.this,SecondActivity.class);
                intent.putExtra("extra_data",data);
                startActivity(intent);
            }
        });
```

在第二个活动中接受

```java
        Intent intent=getIntent();
        String data=intent.getStringExtra("extra_data");
```

若我们需要向第二个活动发送数据之后等待其的回答。我们可以在一个活动中，将`startActivity(intent);`换成`startActivityForResult(intent,1);`

然后重载`AppCompatActivity`类的一个方法。

```java
//    接收从Activity中返回的数据
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode){
            case 1:
                if(resultCode==RESULT_OK){
                    String returnedData=data.getStringExtra("data_return");
                    Log.d(TAG, returnedData);
                }
                break;
            default:
        }
    }
```

我们在第二个活动里面

```java
//        返回数据给上一个Activity
        Button button2=(Button)findViewById(R.id.button_2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent();
                intent.putExtra("data_return","Hello");
                setResult(RESULT_OK,intent);
                finish();
            }
        });
```

## 活动的生命周期

### 返回栈

我们每启动一个新的活动，就会覆盖在原来的活动上面。就像数据结构里面的栈，我们称其为“返回栈”。

### 活动状态

* 活动状态：当一个活动位于返回栈的栈顶时，这时活动就在于运行状态。
* 暂停状态：当一个活动不再处于栈顶位置，但仍可见，此时活动就进入了暂停状态。
* 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候。
* 销毁状态：当一个活动从返回栈中移除后 。

### 活动的生存期

* onCreate()：在活动第一次被创建的时候调用。
* onStart()：在活动有不可见变为可见的时候调用。
* onResume()：在活动准备好和用户进行交互的时候调用。
* onPause()：在系统准备去启动或者恢复另一个活动的时候调用。这个方法一定要快。
* onStop()：在活动完全不可见的时候调用。和onPause()的区别在于。如果启动的新活动是一个对话框的活动，那么onPause()会执行，而onStop()不会执行。
* onDestory()：在活动被销毁之前调用。
* onRestart()：在活动头停止状态变为运行状态之前调用。

![](./static/activity.png)

## 活动的启动模式

我们在manifest文件下面修改启动模式。

```xml
        <activity 
            android:name=".FirstActivity"
            android:launchMode="standard"
            >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
```

### standard

在不指定的情况下，默认。

每当启动一个新的活动，他就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式启动的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。

### singleTop

当活动的启动模式指定为singleTop时，在启动活动时候如果发现返回栈已经是该活动，则认为可以直接使用它。不过如果活动并未处于栈顶的位置，还是会启动新的实例的。

### singleTask

每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在就直接使用，并且把这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。

### singleInstance

活动会启用一个新的返回栈来管理这个活动。

## 关于活动的PS

### 知晓当前是在哪一个活动

```
getClass().getSimpleName()
```

### 随时退出程序

```java
public class ActivityCollector {
    public static List<Activity> activities = new ArrayList<Activity>();

    public static void addActivity(Activity activity) {
        activities.add(activity);
    }

    public static void removeActivity(Activity activity) {
        activities.remove(activity);
    }
    
    public static void finishAll() {
        for (Activity activity : activities) {
            if (!activity.isFinishing()) {
                activity.finish();
            }
        }
    }
}
```

使用一个管理器，重写每个活动的onCreate和onDestory方法。

# UI
##常见控件
### TextView

```xml
<TextView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:text="this is text"
    android:gravity="center"
    />
```

* match_parent：当前空间的大小和父布局大小一样
* wrap_content：当前空间的大小刚好包含住里面的内容

可以同时用`|`来制定多个对齐方式

### Button

### EditText

```xml
    <EditText
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="input somethings"
        android:maxLines="2"/>
```

### ImageView

```xml
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@drawable/ic_launcher_background"/>
```

### ProgressBar

```xml
    <ProgressBar
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
```

### AlertDialog

```java
AlertDialog.Builder dialog = new AlertDialog.Builder(FirstActivity.this);
dialog.setTitle("Title");
dialog.setMessage("Message");
dialog.setCancelable(false);
dialog.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        
    }
});

dialog.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        
    }
});
dialog.show();
```

### ProgressDialog

```java
ProgressDialog progressDialog=new ProgressDialog(FirstActivity.this);
progressDialog.setTitle("Title");
progressDialog.setMessage("Loading...");
progressDialog.setCancelable(true);
progressDialog.show();
```

## 可见与不可见

任何空间都可以用`android:visibility`设定。

* visible：可见
* invisible：不可见
* gone：不仅不可见，而且不占用屏幕空间

我们也可以在代码中

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setVisibility(View.VISIBLE);
```

## 四种布局

### LinearLayout

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="Button"/>

</LinearLayout>
```

我们可以设置`android:orientation="horizontal"`来将布局设置为水平布局。

我们可以设置`android:layout_gravity="center"`来控制控件的位置。有`top`，`bottom`，`center_horizontal`，`center_vertical`，`center`可选。

我们还可以按照比例设置，如下button与textview的比例为一比一。

```xml
    <Button
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"/>

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="this is text"
        android:layout_weight="1"/>
```

### RelativeLayout




