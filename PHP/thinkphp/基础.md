# 基础

## 开发规范

`ThinkPHP5`遵循`PSR-2`命名规范和`PSR-4`自动加载规范，并且注意如下规范：

### 目录和文件

- 目录使用小写+下划线；
- 类库、函数文件统一以`.php`为后缀；
- 类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径一致；
- 类文件采用驼峰法命名（首字母大写），其它文件采用小写+下划线命名；
- 类名和类文件名保持一致，统一采用驼峰法命名（首字母大写）；

### 函数和类、属性命名

- 类的命名采用驼峰法（首字母大写），例如 `User`、`UserType`，默认不需要添加后缀，例如`UserController`应该直接命名为`User`；
- 函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 `get_client_ip`；
- 方法的命名使用驼峰法（首字母小写），例如 `getUserName`；
- 属性的命名使用驼峰法（首字母小写），例如 `tableName`、`instance`；
- 以双下划线“__”打头的函数或方法作为魔术方法，例如 `__call` 和 `__autoload`；

### 常量和配置

- 常量以大写字母和下划线命名，例如 `APP_PATH`和 `THINK_PATH`；
- 配置参数以小写字母和下划线命名，例如 `url_route_on` 和`url_convert`；

### 数据表和字段

- 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 `think_user` 表和 `user_name`字段，不建议使用驼峰和中文作为数据表字段命名。

### 应用类库命名空间规范

应用类库的根命名空间统一为app（不建议更改，可以设置`app_namespace`配置参数更改，`V5.0.8`版本开始使用`APP_NAMESPACE`常量定义）；
例如：`app\index\controller\Index`和`app\index\model\User`。

##目录结构

```
project  应用部署目录
├─application           应用目录（可设置）
│  ├─common             公共模块目录（可更改）
│  ├─index              模块目录(可更改)
│  │  ├─config.php      模块配置文件
│  │  ├─common.php      模块函数文件
│  │  ├─controller      控制器目录
│  │  ├─model           模型目录
│  │  ├─view            视图目录
│  │  └─ ...            更多类库目录
│  ├─command.php        命令行工具配置文件
│  ├─common.php         应用公共（函数）文件
│  ├─config.php         应用（公共）配置文件
│  ├─database.php       数据库配置文件
│  ├─tags.php           应用行为扩展定义文件
│  └─route.php          路由配置文件
├─extend                扩展类库目录（可定义）
├─public                WEB 部署目录（对外访问目录）
│  ├─static             静态资源存放目录(css,js,image)
│  ├─index.php          应用入口文件
│  ├─router.php         快速测试文件
│  └─.htaccess          用于 apache 的重写
├─runtime               应用的运行时目录（可写，可设置）
├─vendor                第三方类库目录（Composer）
├─thinkphp              框架系统目录
│  ├─lang               语言包目录
│  ├─library            框架核心类库目录
│  │  ├─think           Think 类库包目录
│  │  └─traits          系统 Traits 目录
│  ├─tpl                系统模板目录
│  ├─.htaccess          用于 apache 的重写
│  ├─.travis.yml        CI 定义文件
│  ├─base.php           基础定义文件
│  ├─composer.json      composer 定义文件
│  ├─console.php        控制台入口文件
│  ├─convention.php     惯例配置文件
│  ├─helper.php         助手函数文件（可选）
│  ├─LICENSE.txt        授权说明文件
│  ├─phpunit.xml        单元测试配置文件
│  ├─README.md          README 文件
│  └─start.php          框架引导文件
├─build.php             自动生成定义文件（参考）
├─composer.json         composer 定义文件
├─LICENSE.txt           授权说明文件
├─README.md             README 文件
├─think                 命令行入口文件
```

如果是mac或者linux环境，请确保`runtime`目录有可写权限

| a               | a            | a           |
| --------------- | ------------ | ----------- |
| tp5             | 项目根目录        | ROOT_PATH   |
| tp5/application | 应用目录         | APP_PATH    |
| tp5/thinkphp    | 框架核心目录       | THINK_PATH  |
| tp5/exend       | 应用扩展目录       | EXTEND_PATH |
| tp5/vendor      | Composer扩展目录 | VENDOR_PATH |

核心框架目录的结构如下：
├─thinkphp 框架系统目录
│ ├─lang 语言包目录
│ ├─library 框架核心类库目录
│ │ ├─think think 类库包目录
│ │ └─traits 系统 traits 目录
│ ├─tpl 系统模板目录
│ │
│ ├─.htaccess 用于 apache 的重写
│ ├─.travis.yml CI 定义文件
│ ├─base.php 框架基础文件
│ ├─composer.json composer 定义文件
│ ├─console.php 控制台入口文件
│ ├─convention.php 惯例配置文件
│ ├─helper.php 助手函数文件（ 可选）
│ ├─LICENSE.txt 授权说明文件
│ ├─phpunit.xml 单元测试配置文件
│ ├─README.md README 文件
│ └─start.php 框架引导文件

ThinkPHP5.0 版本的默认自带的入口文件位于 public/index.php （实际部署的时候 public 目录为
你的应用对外访问目录），入口文件内容如下：

```php
// 定义应用目录
define('APP_PATH', __DIR__ . '/../application/');
// 加载框架引导文件
require __DIR__ . '/../thinkphp/start.php';
```

这段代码的作用就是定义应用目录 APP_PATH 和加载 ThinkPHP 框架的入口文件，这是所有基于
ThinkPHP 开发应用的第一步。
我们可以在浏览器中访问入口文件
http://localhost/tp5/public/

##模块设计

标准的应用和模块目录结构如下：

```
├─application           应用目录（可设置）
│  ├─common             公共模块目录（可选）
│  ├─common.php         公共函数文件
│  ├─route.php          路由配置文件
│  ├─database.php       数据库配置文件
│  ├─config.php         应用配置文件
│  ├─module1            模块1目录
│  │  ├─config.php      模块配置文件
│  │  ├─common.php      模块函数文件
│  │  ├─controller      控制器目录
│  │  ├─model           模型目录（可选）
│  │  ├─view            视图目录（可选）
│  │  └─ ...            更多类库目录
│  │ 
│  ├─module2            模块2目录
│  │  ├─config.php      模块配置文件
│  │  ├─common.php      模块函数文件
│  │  ├─controller      控制器目录
│  │  ├─model           模型目录（可选）
│  │  ├─view            视图目录（可选）
│  │  └─ ...            更多类库目录
```

其中`common`模块是一个特殊的模块，默认是禁止直接访问的，一般用于放置一些公共的类库用于其他模块的继承。

####模块类库

一个模块下面的类库文件的命名空间统一以`app\模块名`开头，例如：

```
// index模块的Index控制器类
app\index\controller\Index
// index模块的User模型类
app\index\model\User
```

其中`app`可以通过定义的方式更改，例如我们在应用配置文件中修改：

```
'app_namespace' => 'application',
```

那么，index模块的类库命名空间则变成：

```
// index模块的Index控制器类
application\index\controller\Index
// index模块的User模型类
application\index\model\User
```

###添加新的模块

如果我要添加新的模块可以使用控制台命令来生成。切换到命令行模式下，进入到应用根目录并执行如下指令：
`php think build --module demo`

## 命名空间

注意的是，如果你需要调用PHP内置的类库，或者第三方没有使用命名空间的类库，记得在实例化类库的时候加上 `\`，例如：

```
// 错误的用法
$class = new stdClass();
$xml  =  new SimpleXmlElement($xmlstr);
// 正确的用法
$class = new \stdClass();
$xml  =  new \SimpleXmlElement($xmlstr);
```

```
namespace think\cache\driver;

class File 
{
}
```

如果我们实例化该类的话，应该是：

```
$class = new \think\cache\driver\File();
```

系统会自动加载该类对应路径的类文件，其所在的路径是 `thinkphp/library/think/cache/driver/File.php`。

### 自动注册

我们只需要把自己的类库包目录放入`EXTEND_PATH`目录（默认为`extend`，可配置），就可以自动注册对应的命名空间，例如：

我们在`extend`目录下面新增一个`my`目录，然后定义一个`\my\Test`类（ 类文件位于`extend/my/Test.php`）如下：

```
namespace my;

class Test 
{
    public function sayHello()
    {
        echo 'hello';
    }
}
```

我们就可以直接实例化和调用：

```
$Test = new \my\Test();
$Test->sayHello();
```

如果我们在应用入口文件中重新定义了`EXTEND_PATH`常量的话，还可以改变`\my\Test`类文件的位置，例如：

```
define('EXTEND_PATH','../vendor/');
```

那么`\my\Test`类文件的位置就变成了`/vendor/my/File.php`。

####手动注册

也可以通过手动注册的方式注册新的根命名空间，例如：

在应用公共文件中添加下面的代码：

```
\think\Loader::addNamespace('my','../application/extend/my/');
```

如果要同时注册多个根命名空间，可以使用：

```
\think\Loader::addNamespace([
    'my'  => '../application/extend/my/',
    'org' => '../application/extend/org/',
]);
```

也可以直接在应用的配置文件中添加配置，系统会在应用执行的时候自动注册。

```
'root_namespace' => [
    'my'  => '../application/extend/my/',
    'org' => '../application/extend/org/',
]
```

####应用类库包

为了避免和`Composer`自动加载的类库存在冲突 ，应用类库的命名空间的根都统一以`app`命名，例如：

```
namespace app\index\model;

class User extends \think\Model
{
}
```

其类文件位于 `application/index/model/User.php`。

```
namespace app\admin\event;

class User 
{
}
```

其类文件位于 `application/admin/event/User.php`。

如果觉得`app`根命名空间不合适或者有冲突，可以在应用配置文件中修改：

```
'app_namespace' =>  'application',
```

####命名空间别名

框架允许给命名空间定义别名，例如：

```
namespace app\index\model;

use think\Model;

class User extends Model
{
}
```

原来在控制器里面调用方式为：

```
namespace app\index\controller;

use app\index\model\User;

class Index
{
    public function index()
    {
        $user = new User();
    }
}
```

如果我们在应用公共文件中注册命名空间别名如下：

```
\think\Loader::addNamespaceAlias('model','app\index\model');
```

那么，上面的控制器代码就可以更改为：

```
namespace app\index\controller;

use model\User;

class Index
{
    public function index()
    {
        $user = new User();
    }
}
```

## 入口文件定义

入口文件位置的设计是为了让应用部署更安全，`public`目录为web可访问目录，其他的文件都可以放到非WEB访问目录下面。

##控制器

我们找到 index 模块的 Index 控制器（文件位于 application/index/controller/Index.php 注
意大小写），我们把 Index 控制器类的 index 方法修改为 Hello,World！ 。

```
<?php
namespace app\index\controller;
class Index
{
public function index()
{
return 'Hello,World！';
}
}


class Index
{
public function index($name = 'World')
{
return 'Hello,' . $name . '！';
}
}
```
#### protected与private

```
class Index
{
    public function hello()
    {
        return 'hello,thinkphp!';
    }public function test()
    {
        return '这是一个测试方法!';
    }protected function hello2()
    {
        return '只是protected方法!';
    }private function hello3()
    {
        return '这是private方法!';
    }
}
```

`http://127.0.0.1/tp5/public/index.php/index/index/hello`

当我们访问 hello2 和 hello3 操作方法后的结果都会显示类似的异常信息

##视图

我们在 application/index 目录下面创建一个 view 目录，然后添加模板文件 view/index/hello.html ，我们添加模板内容如下：

```
<html>
<head>
    <title>hello {$name}</title>
</head>
<body>
    hello, {$name}!
</body>
</html>
```

```
class Index extends Controller
{
    public function hello($name = 'thinkphp')
    {
        $this->assign('name', $name);
        return $this->fetch();
    }
}
```

 ## 关于权限

`runtime`文件夹需要777权限，`chmod -R 777 runtime`

## 读取数据

首先我们需要在应用的数据库配置文件 application/database.php 中添加数据库的连接信息如下：

```
return [
    // 数据库类型
    'type'            => 'mysql',
    // 服务器地址
    'hostname'        => '127.0.0.1',
    // 数据库名
    'database'        => '',
    // 用户名
    'username'        => 'root',
    // 密码
    'password'        => '',
    // 端口
    'hostport'        => '',
    // 连接dsn
    'dsn'             => '',
    // 数据库连接参数
    'params'          => [],
    // 数据库编码默认采用utf8
    'charset'         => 'utf8',
    // 数据库表前缀
    'prefix'          => '',
    // 数据库调试模式
    'debug'           => true,
    // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)
    'deploy'          => 0,
    // 数据库读写是否分离 主从式有效
    'rw_separate'     => false,
    // 读写分离后 主服务器数量
    'master_num'      => 1,
    // 指定从服务器序号
    'slave_no'        => '',
    // 是否严格检查字段是否存在
    'fields_strict'   => true,
    // 数据集返回类型
    'resultset_type'  => 'array',
    // 自动写入时间戳字段
    'auto_timestamp'  => false,
    // 时间字段取出后的默认时间格式
    'datetime_format' => 'Y-m-d H:i:s',
    // 是否需要进行SQL性能分析
    'sql_explain'     => false,
];
```

# 配置

`惯例配置->应用配置->扩展配置->场景配置->模块配置->动态配置`

* 惯例配置：thinkphp/convention.php
* 应用配置：application/config.php
* 扩展配置：application/extra
* 场景配置：application/office.php
  * 配合配置里面的 'app_status'=>'office'
* 模块配置：application/当前模块名/config.php
  * 还有独立的应用配置：application/当前模块名/应用状态.php

我们亦可以动态加载：

Config::load(APP_PATH.'config/config.php');

## 读取

```
echo Config::get('配置参数1');

dump(Config::get());
// 或者 dump(config());

Config::has('配置参数2');
// 或者 config('?配置参数2');

echo Config::get('配置参数.二级参数');
echo config('配置参数.二级参数');
```

## 设置

```
Config::set('配置参数','配置值');
// 或者使用助手函数
config('配置参数','配置值');

Config::set([
    '配置参数1'=>'配置值',
    '配置参数2'=>'配置值'
]);
// 或者使用助手函数
config([
    '配置参数1'=>'配置值',
    '配置参数2'=>'配置值'
]);
```

## 独立配置

只需要将扩展配置文件放入`application/extra`目录，即可自动读取。

模块也可以支持自己的扩展配置文件，只需要放入 `application/模块名/extra`下面就可以自动加载。

系统默认加载的独立配置文件不在此列，包括：


| 文件名   | 描述                 |
| -------- | -------------------- |
| config   | 应用或者模块配置文件 |
| database | 数据库配置文件       |
| tags     | 行为定义文件         |
| 场景名   | 应用场景配置文件     |

###配置作用域

```
// 导入my_config.php中的配置参数，并纳入user作用域
Config::load('my_config.php','','user'); 
// 解析并导入my_config.ini 中的配置参数，读入test作用域
Config::parse('my_config.ini','ini','test'); 
// 设置user_type参数，并纳入user作用域
Config::set('user_type',1,'user'); 
// 批量设置配置参数，并纳入test作用域
Config::set($config,'test'); 
// 读取user作用域的user_type配置参数
echo Config::get('user_type','user'); 
// 读取user作用域下面的所有配置参数
dump(Config::get('','user')); 
dump(config('',null,'user')); // 同上
// 判断在test作用域下面是否存在user_type参数
Config::has('user_type','test'); 
```

可以使用`range`方法切换当前配置文件的作用域，例如：

```
Config::range('test');
```

### 环境变量配置



## 目录

```
├─application         应用目录
├─config              配置目录
│  ├─config.php       应用配置文件
│  ├─database.php     数据库配置文件
│  ├─route.php        路由配置文件
│  ├─extra            应用扩展配置目录
│  ├─index            index模块配置文件目录
│  │  ├─extra         index模块扩展配置目录
│  │  ├─config.php    index模块配置文件
│  │  └─database.php  index模块数据库配置文件
```



#URL和路由

`http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值...]`

* 如果我们直接访问入口文件的话，由于URL中没有模块、 控制器和操作，因此系统会访问默认模块（index）下面的默认控制器（Index）的默认操作（index），因此下面的访问是等效的：
  * `http://tp5.com/index.php`
  * `http://tp5.com/index.php/index/index/index`


* 果要访问控制器的hello方法，则需要使用完整的URL地址
  * `http://tp5.com/index.php/index/index/hello`
* **如果你的控制器是驼峰的，例如定义一个HelloWorld控制器**（application/index/controller/HelloWorld.php ）正确的URL访问地址（该地址可以使用url方法生成）应该是：

  `http://tp5.com/index.php/index/hello_world/index`
* 如果希望严格区分大小写访问（或者要支持驼峰法进行控制器访问），可以在应用配置文件中设置：`'url_convert' => false,`

如果你的服务器环境不支持 pathinfo 方式的URL访问，可以使用兼容方式，例如：
`http://tp5.com/index.php?s=/index/Index/index`

`http://serverName/index.php?s=/index/index/hello&val=value`

## 路由

* `'url_route_on'`：开路由
* `url_toute_must`：必须路由（不能PATH_INFO）

### Nginx配置

找到location ~ \.php {   ，把$去掉，并在里面加上这两句

```
fastcgi_split_path_info ^(.+.php)(.*)$;     #增加
fastcgi_param PATH_INFO $fastcgi_path_info;    #增加
```

```
location ~ \.php { #去掉$
            root       html
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
            include        fastcgi_params;
            fastcgi_split_path_info ^(.+\.php)(.*)$;     #添加
            fastcgi_param PATH_INFO $fastcgi_path_info;    #添加
        }
```

## 传参

```
<?php
namespace app\index\controller;

class Index
{
    public function index()
    {
        return 'index';
    }public function hello($name = 'World')
    {
        return 'Hello,' . $name . '!';
    }
}
```

`http://tp5.com/index.php/index/index/hello?name=thinkphp`

`http://tp5.com/index.php/index/index/hello/name/thinkphp`

```
public function hello($name = 'World', $city = '')
{
return 'Hello,' . $name . '! You come from ' . $city . '.';
}
```

`http://tp5.com/index.php/index/index/hello/name/thinkphp/city/shanghai`

非严格顺序

`http://tp5.com/index.php/index/index/hello/city/shanghai/name/thinkphp`

`http://tp5.com/index.php/index/index/hello?city=shanghai&name=thinkphp`

强制严格顺序

`'url_param_type' => 1,`

##隐藏index.php

## 定义路由

我们在路由定义文件（ application/route.php ）里面添加一些路由规则，如下：

```
return [
// 添加路由规则 路由到 index控制器的hello操作方法
'hello/[:name]' => 'index/index/hello',
]

//使用 [] 把路由规则中的变量包起来，就表示该变量为可选
```

路由之前的URL访问地址为：
http://tp5.com/index/index/hello/name/thinkphp
定义路由后就只能访问下面的URL地址
http://tp5.com/hello/thinkph

**定义路由规则后，原来的URL地址将会失效，变成非法请求。**

###动态定义



除了路由配置文件中定义之外，还可以采用动态定义路由规则的方式定义，例如在路由配置文件（application/route.php ）的开头直接添加下面的方法：

```
use think\Route;
Route::rule('hello/[:name]', 'index/hello');

Route::get('new/:id','News/read'); // 定义GET请求路由规则
Route::post('new/:id','News/update'); // 定义POST请求路由规则
Route::put('new/:id','News/update'); // 定义PUT请求路由规则
Route::delete('new/:id','News/delete'); // 定义DELETE请求路由规则
Route::any('new/:id','News/read'); // 所有请求都支持的路由规则

Route::rule('new/:id','News/read','GET|POST');

Route::rule(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);
Route::get(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);
Route::post(['new/:id'=>'News/update','blog/:name'=>'Blog/detail']);



Route::rule([
'路由规则1'=>'路由地址和参数',
'路由规则2'=>['路由地址和参数','匹配参数（数组）','变量规则（数组）']
...
],'','请求类型','匹配参数（数组）','变量规则');

Route::rule([
    'new/:id'  =>  'News/read',
    'blog/:id' =>  ['Blog/update',['ext'=>'shtml'],['id'=>'\d{4}']],
    ...
],'','GET',['ext'=>'html'],['id'=>'\d+']);
```

### 完整匹配

```
return [
// 路由参数name为可选
'hello/[:name]$' => 'index/hello',
];

// 开启路由定义的全局完全匹配
'route_complete_match'  =>  true,

Route::rule('new/:id','News/read','GET|POST',['complete_match' => false]);
```

http://tp5.com/hello // 正确匹配
http://tp5.com/hello/thinkphp // 正确匹配
http://tp5.com/hello/thinkphp/val/value // 不会匹配

### 闭包定义

```
return [
// 定义闭包
'hello/[:name]' => function ($name) {
return 'Hello,' . $name . '!';
},
];
```

### 设置URL分隔符

`'pathinfo_depr' => '-',`

`http://tp5.com/hello-thinkphp`

### 路由参数

```
return [
// 定义路由的请求类型和后缀
'hello/[:name]' => ['index/hello', ['method' => 'get', 'ext' => 'html']],
];
```

上面定义的路由规则限制了必须是 get 请求，而且后缀必须是 html 的，所以下面的访问地址：
http://tp5.com/hello // 无效
http://tp5.com/hello.html // 有效
http://tp5.com/hello/thinkphp // 无效
http://tp5.com/hello/thinkphp.html // 有效

##变量规则

```
<?php
namespace app\index\controller;

class Blog
{
    public function get($id)
    {
        return '查看id=' . $id . '的内容';
    }public function read($name)
    {
        return '查看name=' . $name . '的内容';
    }public function archive($year, $month)
    {
        return '查看' . $year . '/' . $month . '的归档内容';
    }
}
```

```
return [
'blog/:year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
];


'/' => 'index', // 首页访问路由
'my'        =>  'Member/myinfo', // 静态地址路由
'blog/:id'  =>  'Blog/read', // 静态地址和动态地址结合
'new/:year/:month/:day'=>'News/read', // 静态地址和动态地址结合
':user/:blog_id'=>'Blog/read',// 全动态地址
```

// 访问id为5的内容
http://tp5.com/blog/5
// 访问name为thinkphp的内容
http://tp5.com/blog/thinkphp
// 访问2015年5月的归档内容
http://tp5.com/blog/2015/05

## 路由分组

上面的三个路由规则由于都是 blog 打头，所以我们可以做如下的简化：

```php
return [
    '[blog]' => [
        ':year/:month' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
        ':id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
        ':name' => ['blog/read', ['method' => 'get|post'], ['name' => '\w+']],
    ],
];

```

## 复杂路由

http://tp5.com/blog/thinkphp
http://tp5.com/blog-2015-05

```
return [
    'blog/:id' => ['blog/get', ['method' => 'get'], ['id' => '\d+']],
    'blog/:name' => ['blog/read', ['method' => 'get'], ['name' => '\w+']],
    'blog-<year>-<month>' => ['blog/archive', ['method' => 'get'], ['year' => '\d{4}', 'month' => '\d{2}']],
];
```

对 blog-<year>-<month> 这样的非正常规范，我们需要使用 <变量名> 这样的变量定义方式，而不是
:变量名 方式。

在 `__pattern__` 中定义的变量规则我们称之为全局变量规则，在路由规则里面定义的变量规则我们称之为
局部变量规则，如果一个变量同时定义了全局规则和局部规则的话，当前的局部规则会覆盖全局规则的

默认情况下，只会加载一个路由配置文件`route.php`，如果你需要定义多个路由文件，可以修改`route_config_file`配置参数，例如：

```
// 定义路由配置文件（数组）
'route_config_file' =>  ['route', 'route1', 'route2'],
```

## 变量规则

### 全局变量规则

设置全局变量规则，全部路由有效：

```
// 设置name变量规则（采用正则定义）
Route::pattern('name','\w+');
// 支持批量添加
Route::pattern([
    'name'  =>  '\w+',
    'id'    =>  '\d+',
]);
```

### 局部变量规则

局部变量规则，仅在当前路由有效：

```
// 定义GET请求路由规则 并设置name变量规则
Route::get('new/:name','News/read',[],['name'=>'\w+']);
```

如果一个变量同时定义了全局规则和局部规则，局部规则会覆盖全局变量的定义。

### 完整URL规则

如果要对整个URL进行规则检查，可以进行`__url__` 变量规则，例如：

```
// 定义GET请求路由规则 并设置完整URL变量规则
Route::get('new/:id','News/read',[],['__url__'=>'new\/\w+$']);
```

## 路由参数



## 生成URL地址

```
use think\Url;
...
public function read($name){
    return '查看name=' . $name . '的内容' . Url::build('blog/read', 'name=' . $name);
}
...
```

如果你配置了 url_html_suffix 参数的话，生成的URL地址会带上后缀。

`'url_html_suffix' => 'html',`

# 请求和响应

```
<?php
namespace app\index\controller;

use think\Controller;

class Index extends Controller
{
    public function hello($name = 'World')
    {
// 获取当前URL地址 不含域名
        echo 'url: ' . $this->request->url() . '<br/>';
        return 'Hello,' . $name . '！';
    }
}
```

或

```
<?php
namespace app\index\controller;
use think\Request;
class Index
{
public function hello(Request $request, $name = 'World')
{
// 获取当前URL地址 不含域名
echo 'url: ' . $request->url() . '<br/>';
return 'Hello,' . $name . '！';
}
}
```

##Request

###动态绑定属性

可以给Request请求对象绑定属性，方便全局调用，例如我们可以在公共控制器中绑定当前登录的用户模型到请求对象：

```
<?php
namespace app\index\controller;

use app\index\model\User;
use think\Controller;
use think\Request;
use think\Session;

class Base extends Controller
{
    public function _initialize()
    {
        $user = User::get(Session::get('user_id'));
        Request::instance()->bind('user', $user);
    }
}


<?php
namespace app\index\controller;

use app\index\controller\Base;
use think\Request;

class Index extends Base
{
    public function index(Request $request)
    {
        echo $request->user->id;
        echo $request->user->name;
    }
}

```

###使用助手函数（最好用）

```
<?php
namespace app\index\controller;

class Index
{
    public function hello($name = 'World')
    {
// 获取当前URL地址 不含域名
        echo 'url: ' . request()->url() . '<br/>';
        return 'Hello,' . $name . '！';
    }
}

```

###获取请求变量

```
<?php
namespace app\index\controller;

use think\Request;

class Index
{
    public function hello(Request $request)
    {
        echo 'GET参数：';
        dump($request->get());
        echo 'GET参数：name';
        dump($request->get('name'));
        echo 'POST参数：name';
        dump($request->post('name'));
        echo 'cookie参数：name';
        dump($request->cookie('name'));
        echo '上传文件信息：image';
        dump($request->file('image'));
        
        dump($request->param());
    }
}


<?php
namespace app\index\controller;

class Index
{
    public function hello()
    {
        echo 'GET参数：';
        dump(input('get.'));
        echo 'GET参数：name';
        dump(input('get.name'));
        echo 'POST参数：name';
        dump(input('post.name'));
        echo 'cookie参数：name';
        dump(input('cookie.name'));
        echo '上传文件信息：image';
        dump(input('file.image'));
    }
}

```
| 获取变量的方法包括 | 方法            |
| --------- | ------------- |
| param     | 获取请求变量        |
| get       | 获取$_GET变量     |
| post      | 获取$_POST变量    |
| put       | 获取PUT请求变量     |
| delete    | 获取DELETE请求变量  |
| patch     | 获取PATCH请求变量   |
| request   | 获取$_REQUEST变量 |
| route     | 获取路由（URL）变量   |
| session   | 获取$_SESSION变量 |
| cookie    | 获取$_COOKIE变量  |
| server    | 获取$_SERVER变量  |
| env       | 获取$_ENV变量     |
| file      | 获取上传文件信息      |
###获取请求参数

```php
<?php
namespace app\index\controller;

use think\Request;

class Index
{
    public function hello(Request $request)
    {
        echo '请求方法：' . $request->method() . '<br/>';
        echo '资源类型：' . $request->type() . '<br/>';
        echo '访问IP：' . $request->ip() . '<br/>';
        echo '是否AJax请求：' . var_export($request->isAjax(), true) . '<br/>';
        echo '请求参数：';
        dump($request->param());
        echo '请求参数：仅包含name';
        dump($request->only(['name']));
        echo '请求参数：排除name';
        dump($request->except(['name']));
    }
}

```

###获取URL信息

```php
<?php
namespace app\index\controller;

use think\Request;

class Index
{
    public function hello(Request $request, $name = 'World')
    {
// 获取当前域名
        echo 'domain: ' . $request->domain() . '<br/>';
// 获取当前入口文件
        echo 'file: ' . $request->baseFile() . '<br/>';
// 获取当前URL地址 不含域名
        echo 'url: ' . $request->url() . '<br/>';
// 获取包含域名的完整URL地址
        echo 'url with domain: ' . $request->url(true) . '<br/>';
// 获取当前URL地址 不含QUERY_STRING
        echo 'url without query: ' . $request->baseUrl() . '<br/>';
// 获取URL访问的ROOT地址
        echo 'root:' . $request->root() . '<br/>';
// 获取URL访问的ROOT地址
        echo 'root with domain: ' . $request->root(true) . '<br/>';
// 获取URL地址中的PATH_INFO信息
        echo 'pathinfo: ' . $request->pathinfo() . '<br/>';
// 获取URL地址中的PATH_INFO信息 不含后缀
        echo 'pathinfo: ' . $request->path() . '<br/>';
// 获取URL地址中的后缀信息
        echo 'ext: ' . $request->ext() . '<br/>';
        return 'Hello,' . $name . '！';
    }
}

```
| URL请求和信息方法可以总结如下 | 方法                        |
| ---------------- | ------------------------- |
| domain           | 获取当前的域名                   |
| url              | 获取当前的完整URL地址              |
| baseUrl          | 获取当前的URL地址，不含QUERY_STRING |
| baseFile         | 获取当前的SCRIPT_NAME          |
| root             | 获取当前URL的root地址            |
| pathinfo         | 获取当前URL的pathinfo地址        |
| path             | 获取当前URL的pathinfo地址，不含后缀   |
| ext              | 获取当前URL的后缀                |
| type             | 获取当前请求的资源类型               |
| scheme           | 获取当前请求的scheme             |
| query            | 获取当前URL地址的QUERY_STRING    |
| host             | 获取当前URL的host地址            |
| port             | 获取当前URL的port号             |
| protocol         | 获取当前请求的SERVER_PROTOCOL    |
| remotePort       | 获取当前请求的REMOTE_PORT        |
###获取当前模块/控制器/操作信息

```php
public function hello(Request $request, $name = 'World')
{
echo '模块：'.$request->module();
echo '<br/>控制器：'.$request->controller();
echo '<br/>操作：'.$request->action();
}
```

###获取路由和调度信息

## Response

###自动输出

大多数情况，我们不需要关注 Response 对象本身，只需要在控制器的操作方法中返回数据即可，系统会根据 default_return_type 和 default_ajax_return 配置决定响应输出的类型。

`'default_return_type' => 'json',`或者`'default_return_type' => 'xml',`

```php
<?php
namespace app\index\controller;

class Index
{
    public function hello()
    {
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return $data;
    }
}
```

### 手动输出

```php
<?php
namespace app\index\controller;

class Index
{
    public function hello()
    {
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data);
    }
}


//状态码
<?php
namespace app\index\controller;

class Index
{
    public function hello()
    {
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data, 201);
    }
}

//或者发送更多的响应头信息
<?php
namespace app\index\controller;

class Index
{
    public function hello()
    {
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data, 201, ['Cache-control' => 'no-cache,must-revalidate']);
    }
}

//亦可以这样
class Index
{
    public function hello()
    {
        $data = ['name' => 'thinkphp', 'status' => '1'];
        return json($data)->code(201)->header(['Cache-control' => 'no-cache,must-revali
date', ]);
    }
}
```

| 默认支持的输出类型包括 | 输出类型     |
| ----------- | -------- |
| 渲染模板输出      | view     |
| JSON输出      | json     |
| JSONP输出     | jsonp    |
| XML输出       | xml      |
| 页面重定向       | redirect |

### 页面跳转

```php
use \traits\controller\Jump;
public function index($name='')
{
    if ('thinkphp' == $name) {
        $this->success('欢迎使用ThinkPHP5.0','hello');
    } else {
        $this->error('错误的name','guest');
    }
}
```

### 页面重定向

```php
namespace app\index\controller;

class Index
{
    use \traits\controller\Jump;
    public function index($name = '')
    {
        if ('thinkphp' == $name) {
            $this->redirect('http://thinkphp.cn');
        } else {
            $this->success('欢迎使用ThinkPHP', 'hello');
        }
    }public function hello()
    {
        return 'Hello,ThinkPHP!';
    }
}
```

# 数据库

pass

# 查询语言

pass

# 模型和关联

## 模型定义

```
CREATE TABLE IF NOT EXISTS `think_user`(
`id` int(8) unsigned NOT NULL AUTO_INCREMENT,
`nickname` varchar(50) NOT NULL COMMENT '昵称',
`email` varchar(255) NULL DEFAULT NULL COMMENT '邮箱',
`birthday` int(11) UNSIGNED NOT NULL DEFAULT '0' COMMENT '生日',
`status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '状态',
`create_time` int(11) UNSIGNED NOT NULL DEFAULT '0' COMMENT '注册时间',
`update_time` int(11) UNSIGNED NOT NULL DEFAULT '0' COMMENT '更新时间',
PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 ;
```

database.php

```php
return [
    // 数据库类型
    'type' => 'mysql',
    // 服务器地址
    'hostname' => '127.0.0.1',
    // 数据库名
    'database' => 'demo',
    // 数据库用户名
    'username' => 'root',
    // 数据库密码
    'password' => '',
    // 数据库连接端口
    'hostport' => '',
    // 数据库连接参数
    'params' => [],
    // 数据库编码默认采用utf8
    'charset' => 'utf8',
    // 数据库表前缀
    'prefix' => 'think_',
    // 数据库调试模式
    'debug' => true,
];
```

route.php

```php
return [
    // 全局变量规则定义
    '__pattern__' => [
        'id' => '\d+',
    ],
    'user/index' => 'index/user/index',
    'user/create' => 'index/user/create',
    'user/add' => 'index/user/add',
    'user/add_list' => 'index/user/addList',
    'user/update/:id' => 'index/user/update',
    'user/delete/:id' => 'index/user/delete',
    'user/:id' => 'index/user/read',
];
```

定义模型

```php
namespace app\index\model;
use think\Model;
class User extends Model{
  
}

//自定义表名
class User extends Model{
  // 设置完整的数据表（ 包含前缀），如果不指定，默认“前缀+类名”
protected $table = 'think_user';
}

class User extends Model{
// 设置数据表（ 不含前缀）
protected $name = 'member';
}

//指定主键
 class User extends Model
{
    protected $pk = 'uid';
}   


//单独设置数据库
namespace app\index\model;
use think\Model;
class User extends Model
{
// 设置单独的数据库连接
    protected $connection = [
// 数据库类型
        'type' => 'mysql',
// 服务器地址
        'hostname' => '127.0.0.1',
// 数据库名
        'database' => 'test',
// 数据库用户名
        'username' => 'root',
// 数据库密码
        'password' => '',
// 数据库连接端口
        'hostport' => '',
// 数据库连接参数
        'params' => [],
// 数据库编码默认采用utf8
        'charset' => 'utf8',
// 数据库表前缀
        'prefix' => 'think_',
// 数据库调试模式
        'debug' => true,
    ];
}

// 静态调用
$user = User::get(1);
$user->name = 'thinkphp';
$user->save();

// 实例化模型
$user = new User;
$user->name= 'thinkphp';
$user->save();

// 使用 Loader 类实例化（单例）
$user = Loader::model('User');

// 或者使用助手函数`model`
$user = model('User');
$user->name= 'thinkphp';
$user->save();
```

模型会自动对应一个数据表，规范是：数据库前缀+当前的模型类名（不含命名空间）

## 初始化

```php
namespace app\index\model;

use think\Model;

class Index extends Model
{

    //自定义初始化
    protected function initialize()
    {
        //需要调用`Model`的`initialize`方法
        parent::initialize();
        //TODO:自定义的初始化
    }
}


namespace app\index\model;

use think\Model;

class Index extends Model
{

    //自定义初始化
    protected static function init()
    {
        //TODO:自定义的初始化
    }
}
```



## 基础操作

### 增

```php
$user           = new User;
$user->name     = 'thinkphp';
$user->email    = 'thinkphp@qq.com';
$user->save();


$user = new User;
$user->data([
    'name'  =>  'thinkphp',
    'email' =>  'thinkphp@qq.com'
]);
$user->save();


$user = new User([
    'name'  =>  'thinkphp',
    'email' =>  'thinkphp@qq.com'
]);
$user->save();


$user = new User($_POST);
// 过滤post数组中的非数据表字段数据
$user->allowField(true)->save();


$user = new User($_POST);
// post数组中只有name和email字段会写入
$user->allowField(['name','email'])->save();


$user = User::create([
    'name'  =>  'thinkphp',
    'email' =>  'thinkphp@qq.com'
]);
echo $user->name;
echo $user->email;
echo $user->id; // 获取自增ID


// 使用model助手函数实例化User模型
$user = model('User');
// 模型对象赋值
$user->data([
    'name'  =>  'thinkphp',
    'email' =>  'thinkphp@qq.com'
]);
$user->save();
```

默认情况下，实例化模型类后执行 save 操作都是执行的数据库 insert 操作，如果你需要实例化执行
save 执行数据库的 update 操作，请确保在save方法之前调用 isUpdate 方法：
`$user->isUpdate()->save();`

####批量

```php
// 批量新增用户数据
    public function addList()
    {
        $user = new UserModel;
        $list = [
            ['nickname' => '张三', 'email' => 'zhanghsan@qq.com', 'birthday' => strtotime('1988-01-15')],
            ['nickname' => '李四', 'email' => 'lisi@qq.com', 'birthday' => strtotime('1990-0 9-19')],
        ];
        if ($user->saveAll($list)) {
            return '用户批量新增成功';
        } else {
            return $user->getError();
        }
    }


$user = model('User');
// 批量新增
$list = [
    ['name'=>'thinkphp','email'=>'thinkphp@qq.com'],
    ['name'=>'onethink','email'=>'onethink@qq.com']
];
$user->saveAll($list);
```

### 查

####普通查询

```php
$user = User::get(1);
// 使用数组查询
$user = User::get(['name' => 'thinkphp']);

// 使用闭包查询
$user = User::get(function($query){
    $query->where('name', 'thinkphp');
});

//动态查询
// 根据name字段查询用户
$user = User::getByName('thinkphp');

// 根据email字段查询用户
$user = User::getByEmail('thinkphp@qq.com');
```

#### 构造器

```php
    // 根据nickname读取用户数据
    public function read()
    {
        $user = UserModel::where('nickname', '流年')->find();
        echo $user->nickname . '<br/>';
        echo $user->email . '<br/>';
        echo date('Y/m/d', $user->birthday) . '<br/>';
    }


$user = new User();
// 查询单个数据
$user->where('name', 'thinkphp')
    ->find();
//静态
$user = UserModel::where('nickname', '流年')->find();
User::where('id','>',10)->select();
User::where('name','thinkphp')->find();

//查找列
// 获取某个用户的积分
User::where('id',10)->value('score');
// 获取某个列的所有值
User::where('status',1)->column('name');
// 以id为索引
User::where('status',1)->column('name','id');
User::where('status',1)->column('id,name'); // 同tp3的getField
```

`get`或者`find`方法返回的是当前模型的对象实例，可以使用模型的方法。

模型的`all`方法或者`select`方法返回的是一个包含模型对象的二维数组或者数据集对象。

#### 查询全部

```php
// 根据主键获取多个数据
$list = User::all('1,2,3');
// 或者使用数组
$list = User::all([1,2,3]);
foreach($list as $key=>$user){
    echo $user->name;
}
// 使用数组查询
$list = User::all(['status'=>1]);
// 使用闭包查询
$list = User::all(function($query){
    $query->where('status', 1)->limit(3)->order('id', 'asc');
});
foreach($list as $key=>$user){
    echo $user->name;
}


$user = new User();
// 查询数据集 or UserModel::where
$user->where('name', 'thinkphp')
    ->limit(10)
    ->order('id', 'desc')
    ->select();
```

#### 显示数据

```php
$user = User::get(1);
// 获取全部获取器数据
dump($user->toArray());

$user = User::get(1);
// 通过获取器获取字段
echo $user->status;
// 获取原始字段数据
echo $user->getData('status');
// 获取全部原始数据
dump($user->getData());
```

#### 分段

```php
User::chunk(100,function($users){
    foreach($users as $user){
        // 处理user模型对象
    }
});
```

#### 缓存

```php
$user = User::get(1,'',true);
$list  = User::all('1,2,3','',true);
```

#### 主库读取

```php
// 从主库读取数据
$user->master()->get($user->id);


//或者配置 主库写入后从主从库读取
'read_master'	=> true

//或者
$user->readMaster()->save();
// 后续该模型的操作从主库读取数据
```



### 改

模型的新增和更新方法都是`save`方法，系统有一套默认的规则来识别当前的数据需要更新还是新增。

- 实例化模型后调用save方法表示新增；
- 查询数据后调用save方法表示更新；
- save方法传入更新条件后表示更新；

```php
public function update($id)
{
    $user = UserModel::get($id);
    $user->nickname = '刘晨';
    $user->email = 'liu21st@gmail.com';
    if (false !== $user->save()) {
        return '更新用户成功';
    } else {
        return $user->getError();
    }
}


$user = new User;
// save方法第二个参数为更新条件
$user->save([
    'name'  => 'thinkphp',
    'email' => 'thinkphp@qq.com'
],['id' => 1]);


//批量修改
$user = new User;
$list = [
    ['id'=>1, 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com'],
    ['id'=>2, 'name'=>'onethink', 'email'=>'onethink@qq.com']
];
$user->saveAll($list);

//强制更新而不是新增
$user = new User;
$list = [
    ['id'=>1, 'name'=>'thinkphp', 'email'=>'thinkphp@qq.com'],
    ['id'=>2, 'name'=>'onethink', 'email'=>'onethink@qq.com']
];
$user->isUpdate()->saveAll($list);

//强制新增
$user = User::get(1);
$user->name = 'thinkphp';
// 显式指定当前操作为新增操作
$user->isUpdate(false)->save();

//查询后修改
$user = new User;
$user->where('id', 1)
    ->update(['name' => 'thinkphp']);

//或者
$user = new User;
$user->update(['id' => 1, 'name' => 'thinkphp']);

//静态方法
User::where('id', 1)
    ->update(['name' => 'thinkphp']);

//或者
User::update(['id' => 1, 'name' => 'thinkphp']);


//使用闭包
$user = new User;
$user->save(['name' => 'thinkphp'],function($query){
    // 更新status值为1 并且id大于10的数据
    $query->where('status', 1)->where('id', '>', 10);
});
```

注意不要在一个模型实例里面做多次更新，会导致部分重复数据不再更新，正确的方式应该是先查询后更新或者使用模型类的`update`方法更新。

如果你调用save方法进行多次数据写入的时候，需要注意，第二次save方法的时候必须使用isUpdate(false)，否则会视为更新数据。

###删

```php
$user = User::get(1);
$user->delete();


//静态方法
User::destroy(1);
// 支持批量删除多个数据
User::destroy('1,2,3');
// 或者
User::destroy([1,2,3]);
// 删除状态为0的数据
User::destroy(['status' => 0]);
//闭包
User::destroy(function($query){
    $query->where('id','>',10);
});
//数据库查询删除
User::where('id','>',10)->delete();
```

##聚合

| 方法  | 说明                                     |
| ----- | ---------------------------------------- |
| count | 统计数量，参数是要统计的字段名（可选）   |
| max   | 获取最大值，参数是要统计的字段名（必须） |
| min   | 获取最小值，参数是要统计的字段名（必须） |
| avg   | 获取平均值，参数是要统计的字段名（必须） |
| sum   | 获取总分，参数是要统计的字段名（必须）   |

```php
User::count();
User::where('status','>',0)->count();
User::where('status',1)->avg('score');
User::max('score');

$user = new User;
$user->count();
$user->where('status','>',0)->count();
$user->where('status',1)->avg('score');
$user->max('score');
```

## 获取器

获取器的作用是在获取数据的字段值后自动进行处理，例如，我们需要对状态值进行转换，可以使用：

```php
class User extends Model 
{
    public function getStatusAttr($value)
    {
        $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
        return $status[$value];
    }
}

//数据表的字段会自动转换为驼峰法
$user = User::get(1);
echo $user->status; // 例如输出“正常”


//获取器方法的第二个参数传入的是当前的所有数据数组。
class User extends Model 
{
    public function getStatusTextAttr($value,$data)
    {
        $status = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
        return $status[$data['status']];
    }
}
//status_text不是模型本来有的字段
$user = User::get(1);
echo $user->status_text; // 例如输出“正常”
```

## 修改器

修改器的作用是可以在数据赋值的时候自动进行转换处理，例如：

```
class User extends Model 
{
    public function setNameAttr($value)
    {
        return strtolower($value);
    }
}
```

在调用对象的`save`方法时，会自动序列化。

```php
$user = new User();
$user->name = 'THINKPHP';
$user->save();
echo $user->name; // thinkphp

$user = new User();
$data['name'] = 'THINKPHP';
$data['email'] = 'thinkphp@qq.com';
$user->data($data, true);
$user->save();
echo $user->name; // thinkphp

$user = new User();
$data['name'] = 'THINKPHP';
$data['email'] = 'thinkphp@qq.com';
$user->save($data);
echo $user->name; // thinkphp
```

## 时间戳（修改时间）

```php
//第一种，在配置文件
// 开启自动写入时间戳字段
'auto_timestamp' => true,

//第二种，在模块类中
protected $autoWriteTimestamp = true;


// 默认int，如需要datetime
'auto_timestamp' => 'datetime',
protected $autoWriteTimestamp = 'datetime';

class User extends Model 
{
    // 定义时间戳字段名
    protected $createTime = 'create_at';
    protected $updateTime = 'update_at';
}

class User extends Model 
{
    // 关闭自动写入update_time字段
    protected $updateTime = false;
}

class User extends Model 
{
    // 关闭自动写入时间戳
    protected $autoWriteTimestamp = false;
}
```

字段名默认创建时间字段为`create_time`，更新时间字段为`update_time`，支持的字段类型包括`timestamp/datetime/int`。

写入数据的时候，系统会自动写入`create_time`和`update_time`字段，而不需要定义修改器。

`V5.0.5+`版本开始，时间字段输出的时候会自动进行格式转换，如果不希望自动格式化输出，可以把数据库配置文件的 `datetime_format` 参数值改为`false`

## 只读字段

```php
class User extends Model
{
	protected $readonly = ['name','email'];
}
```

## 软删除

```php
namespace app\index\model;

use think\Model;
use traits\model\SoftDelete;

class User extends Model
{
    use SoftDelete;
    protected $deleteTime = 'delete_time';
}

// 软删除
User::destroy(1);
// 真实删除
User::destroy(1,true);
$user = User::get(1);
// 软删除
$user->delete();
// 真实删除
$user->delete(true);

//查询包含软删除的数据
User::withTrashed()->find();
User::withTrashed()->select();

//仅仅查询软删除的数据
User::onlyTrashed()->find();
User::onlyTrashed()->select();
```

`deleteTime`属性用于定义你的软删除标记字段，`ThinkPHP5`的软删除功能使用时间戳类型（数据表默认值为`Null`），用于记录数据的删除时间。

## 类型转换

支持给字段设置类型自动转换，会在写入和读取的时候自动进行类型转换处理。

数据库查询默认取出来的数据都是字符串类型，如果需要转换为其他的类型，需要设置

```php
class User extends Model 
{
    protected $type = [
        'status'    =>  'integer',
        'score'     =>  'float',
        'birthday'  =>  'datetime',
        'info'      =>  'array',
    ];
   /*
   其他类型：
   boolean：
   array：编码为json写入数据库
   object：编码为json
   serialize：序列化
   json：json_encode写入，json_decode读取
   timestamp：见后面
   datetime：和timestamp类似，区别在于写入和读取数据的时候都会自动处理成时间字符串Y-m-d H:i:s的格式。
   */
}

$user = new User;
$user->status = '1';
$user->score = '90.50';
$user->birthday = '2015/5/1';
$user->info = ['a'=>1,'b'=>2];
$user->save();
var_dump($user->status); // int 1
var_dump($user->score); // float 90.5;
var_dump($user->birthday); // string '2015-05-01 00:00:00'
var_dump($user->info);// array (size=2) 'a' => int 1  'b' => int 2
```

指定为时间戳字段类型的话，该字段的值在写入时候会自动使用`strtotime`生成对应的时间戳，输出的时候会自动转换为`dateFormat`属性定义的时间字符串格式，默认的格式为`Y-m-d H:i:s`，如果希望改变其他格式，可以定义如下：

```php
class User extends Model 
{
    protected $type = [
        'status'    =>  'integer',
        'score'     =>  'float',
        'birthday'  =>  'timestamp:Y/m/d',
    ];
}

$user = User::find(1);
echo $user->birthday; // 2015/5/1
```

## 数据完成

数据自动完成指在不需要手动赋值的情况下对字段的值进行处理后写入数据库。

系统支持`auto`、`insert`和`update`三个属性，可以分别在写入、新增和更新的时候进行字段的自动完成机制，auto属性自动完成包含新增和更新操作。

```php
namespace app\index\model;

use think\Model;

class User extends Model
{
    protected $auto = [];
    protected $insert = ['ip','status' => 1];  
    protected $update = ['login_ip'];  
    
    protected function setIpAttr()
    {
        return request()->ip();
    }
}

//在新增数据的时候，会对ip和 status 字段自动完成或者处理。
```

## 查询范围

```php
namespace app\index\model;

use think\Model;

class User extends Model
{

    protected function scopeThinkphp($query)
    {
        $query->where('name','thinkphp')->field('id,name');
    }
    
    protected function scopeAge($query)
    {
        $query->where('age','>',20)->limit(10);
    }    
    
}


// 查找name为thinkphp的用户
User::scope('thinkphp')->find();
// 查找年龄大于20的10个用户
User::scope('age')->select();
// 查找name为thinkphp的用户并且年龄大于20的10个用户
User::scope('thinkphp,age')->select();


//动态调用
$user = new User;
// 查找name为thinkphp的用户
$user->thinkphp()->get();
// 查找年龄大于20的10个用户
$user->age()->all();
// 查找name为thinkphp的用户并且年龄大于20的10个用户
$user->thinkphp()->age()->all();


//闭包亦可以
namespace app\index\model;

use think\Model;

class User extends Model
{

    protected function scopeAgeAbove($query, $lowest_age)
    {
        $query->where('age','>',$lowest_age)->limit(10);
    }    
}

User::scope('ageAbove', 20)->select();
```

**scope 的name  驼峰的 只能 ageAbove AgeAbove  不支持 age_above**

## 模型分层

例如在`index`模块的设计中需要区分数据层、逻辑层、服务层等不同的模型层，我们可以在模块目录下面创建`model`、`logic`和`service`目录，把对用户表的所有模型操作分成三层：

- 数据层：app\index\model\User 用于定义数据相关的自动验证和自动完成和数据存取接口
- 逻辑层：app\index\logic\User 用于定义用户相关的业务逻辑
- 服务层：app\index\service\User 用于定义用户相关的服务接口等

三个模型层的定义如下：

app\index\model\User.php

```
namespace app\index\model;

use think\Model;

class User extends Model
{
}
```

实例化方法：`\think\Loader::model('User')`

Logic类：app\index\logic\User.php

```
namespace app\index\logic;

use think\Model;

class User extends Model
{
}
```

实例化方法：`\think\Loader::model('User','logic');`

Service类：app\index\service\User.php

```
namespace app\index\service;

use think\Model;

class User extends Model
{
}
```

实例化方法：`\think\Loader::model('User','service');`

## 数组访问和转换

模型对象支持数组方式访问

```php
$user = User::find(1);
echo $user->name ; // 有效
echo $user['name'] // 同样有效
```

### 转换为数组

```php
$user = User::find(1);
dump($user->hidden(['create_time','update_time'])->toArray());

$user = User::find(1);
dump($user->append(['status_text'])->toArray());

$user = User::find(1);
dump($user->visible(['id','name','email'])->toArray());

//如果查询返回的是一个数组
$list = User::all();
if($list) {
    $list = collection($list)->toArray();
}

//可以设置默认返回collection
<?php

namespace app\index\model;

use think\Model;

class User extends Model
{
    protected $resultSetType = 'collection';
}

```

### 追加关联模型的属性

```php
$user = User::find(1);
dump($user->appendRelationAttr('profile',['email','nickname'])->toArray());

$user = User::get(1,'profile');
// 隐藏profile关联属性的email属性
dump($user->hidden(['profile'=>['email']])->toArray());
// 或者使用
dump($user->hidden(['profile.email'])->toArray());
```

`profile`是关联定义方法名，`email`和`nickname`是`Profile`模型的属性。

## JSON序列化

```php
$user = User::get(1);
echo $user->toJson();

//同上append这些都可以用
$user = User::get(1);
echo $user->hidden(['create_time','update_time'])->toJson();

//可以追加关联模型的属性，同上

//模型对象可以直接被JSON序列化
echo json_encode(User::get(1));
echo User::get(1);
```

## 事件

模型事件是指在进行模型的写入操作的时候触发的操作行为，包括模型的save方法和delete方法。**只对模型有效**

| 标签位        | 描述   |
| ------------- | ------ |
| before_insert | 新增前 |
| after_insert  | 新增后 |
| before_update | 更新前 |
| after_update  | 更新后 |
| before_write  | 写入前 |
| after_write   | 写入后 |
| before_delete | 删除前 |
| after_delete  | 删除后 |

```php
//before_write、before_insert、 before_update 、before_delete事件方法如果返回false，则不会继续执行。
User::event('before_insert', function ($user) {
    if ($user->status != 1) {
        return false;
    }
});

//可以注册回调
User::event('before_insert', function ($user) {
    if ($user->status != 1) {
        return false;
    }
});
// 注册回调到beforeInsert函数
User::event('before_insert', 'beforeInsert');
```

可以在`protected static function init()`里面同一注册模型事件。

### 快速注册

```php
namespace app\index\model;

use think\Model;

class User extends Model
{
    protected static function init()
    {
        User::beforeInsert(function ($user) {
            if ($user->status != 1) {
                return false;
            }
        });
    }
}
```

| 标签位       | 描述   |
| ------------ | ------ |
| beforeInsert | 新增前 |
| afterInsert  | 新增后 |
| beforeUpdate | 更新前 |
| afterUpdate  | 更新后 |
| beforeWrite  | 写入前 |
| afterWrite   | 写入后 |
| beforeDelete | 删除前 |
| afterDelete  | 删除后 |

## 关联

### 一对一

#### 定义

例如，一个用户都有一个个人资料，我们定义`User`模型如下

```php
namespace app\index\model;

use think\Model;

class User extends Model
{
    public function profile()
    {
        return $this->hasOne('Profile');
        //指定关联外键
        return $this->hasOne('Profile','uid');
    }
}
```

`hasOne('关联模型名','外键名','主键名',['模型别名定义'],'join类型');`

默认的`join`类型为`INNER`。

**关联方法的命名规范是驼峰法，而关联属性则一般是小写+下划线的方式，系统在获取的时候会自动转换对应，读取`user_profile`关联属性则对应的关联方法应该是`userProfile`。**

#### 关联操作

```php
//查找
$user = User::get(1);
// 输出Profile关联模型的email属性
echo $user->profile->email;

//关联查询
$user = User::hasWhere('profile',['email'=>'thinkphp@qq.com'])->find();
echo $user->name;

//新增
$user = User::get(1);
// 如果还没有关联数据 则进行新增
$user->profile()->save(['email' => 'thinkphp']);

//更新
$user = User::get(1);
$user->profile->email = 'thinkphp';
$user->profile->save();
// 或者
$user->profile->save(['email' => 'thinkphp']);
```

### 定义相对的关联

```php
namespace app\index\model;

use think\Model;

class Profile extends Model 
{
    public function user()
    {
        return $this->belongsTo('User');
        //默认外键是user_id，或可以指定
        return $this->belongsTo('User','uid');
    }
}

//反向查询
$profile = Profile::get(1);
// 输出User关联模型的属性
echo $profile->user->account;
```

`belongsTo('关联模型名','外键名','关联表主键名',['模型别名定义'],'join类型');`

### 绑定属性到父模型

```php
<?php
namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this->hasOne('Profile','uid')->bind('nickname,email');
    }
}

//或者
<?php
namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function profile()
    {
        return $this->hasOne('Profile','uid')->bind([
        		'email',
                'truename'	=> 'nickname',
                'profile_id'  => 'id',
            ]);
    }
}

$user = User::get(1,'profile');
// 输出Profile关联模型的email属性
echo $user->email;
echo $user->profile_id;
```

### 关联自动写入

写入

```
$blog = new Blog;
$blog->name = 'thinkphp';
$blog->title = 'ThinkPHP5关联实例';
$content = new Content;
$content->data = '实例内容';
$blog->content = $content;
$blog->together('content')->save();
```

更新

```
// 查询
$blog = Blog::get(1);
$blog->title = '更改标题';
$blog->content->data = '更新内容';
// 更新当前模型及关联模型
$blog->together('content')->save();
```

删除

```
// 查询
$blog = Blog::get(1);
// 删除当前及关联模型
$blog->together('content')->delete();
```

### 一对多

#### 定义

例如一篇文章可以有多个评论

`hasMany('关联模型名','外键名','主键名',['模型别名定义']);`

```php
<?php
namespace app\index\model;

use think\Model;

class Article extends Model 
{
    public function comments()
    {
        return $this->hasMany('Comment');
        // return $this->hasMany('Comment','art_id');
        //return $this->hasMany('Comment')->field('id,author,content');

    }
}

//Comment
class Comment extends Model 
{
    public function article()
    {
        return $this->belongsTo('article');
    }
}
```

#### 操作

```php
//查询
$article = Article::get(1);
// 获取文章的所有评论
dump($article->comments);
// 也可以进行条件搜索
dump($article->comments()->where('status',1)->select());

// 查询评论超过3个的文章
$list = Article::has('comments','>',3)->select();
// 查询评论状态正常的文章
$list = Article::hasWhere('comments',['status'=>1])->select();
// 查询评论状态正常的文章
$list = Article::hasWhere('comments', ['status'=>1], 'name,title')
	->select();

//新增
$article = Article::find(1);
// 增加一个关联数据
$article->comments()->save(['content'=>'test']);
// 批量增加关联数据
$article->comments()->saveAll([
    ['content'=>'thinkphp'],
    ['content'=>'onethink'],
]);
```

## 远程一对多

#### 定义

远程一对多关联用于定义有跨表的一对多关系，例如：

- 每个城市有多个用户
- 每个用户有多个话题
- 城市和话题之间并无关联

```php
<?php
namespace app\index\model;

use think\Model;

class City extends Model 
{
    public function topics()
    {
        return $this->hasManyThrough('Topic','User');
    }
}

$city = City::get(1);
// 获取同城的所有话题
dump($city->topics);
// 也可以进行条件搜索
dump($city->topics()->where('topic.status',1)->select());
```

`hasManyThrough('关联模型名','中间模型名','外键名','中间模型关联键名','当前模型主键名',['模型别名定义']);`

## 多对多

我们的用户和角色就是一种多对多的关系，我们在User模型定义如下：

```php
<?php
namespace app\index\model;

use think\Model;

class User extends Model 
{
    public function roles()
    {
        return $this->belongsToMany('Role');
    }
}

<?php
namespace app\index\model;

use think\Model;

class Role extends Model 
{
    public function users()
    {
        return $this->belongsToMany('User');
    }
}

    public function roles()
    {
        return $this->belongsToMany('Role','\app\index\model\Access');
    }
```

`belongsToMany('关联模型名','中间表名','外键名','当前模型关联键名',['模型别名定义']);`

```php
//查询
$user = User::get(1);
$roles = $user->roles;
foreach($roles as $role){
    // 获取中间表数据,一个用户多个角色
    dump($role->pivot);
}


//新增
$user = User::get(1);
// 增加关联数据 会自动写入中间表数据
$user->roles()->save(['name'=>'管理员']);
// 批量增加关联数据
$user->roles()->saveAll([
    ['name'=>'管理员'],
    ['name'=>'操作员'],
]);

//只新增中间表
$user = User::get(1);
// 仅增加关联的中间表数据
$user->roles()->save(1);
// 或者
$role = Role::get(1);
$user->roles()->save($role);
// 批量增加关联数据
$user->roles()->saveAll([1,2,3]);

//单独更新中间表
$user = User::get(1);
// 增加关联的中间表数据
$user->roles()->attach(1);
// 传入中间表的额外属性
$user->roles()->attach(1,['remark'=>'test']);
// 删除中间表数据
$user->roles()->detach([1,2,3]);

//V5.0.6+版本开始，attach方法的返回值是一个Pivot对象实例，如果是附加多个关联数据，则返回Pivot对象实例的数组。
```

## 多态关联

### 多态一对多

```s
article
    id - integer
    title - string
    content - text

book
    id - integer
    title - string

comment
    id - integer
    content - text
    commentable_id - integer
    commentable_type - string
```

有两个需要注意的字段是 `comment` 表中的 `commentable_id` 和 `commentable_type`我们称之为多态字段。其中， `commentable_id` 用于存放书或者文章的 id（主键） ，而 `commentable_type` 用于存放所属模型的类型。通常的设计是多态字段有一个公共的前缀（例如这里用的`commentable`），当然，也支持设置完全不同的字段名（例如使用`data_id`和`type`）。

```
<?php
namespace app\index\model;

use think\Model;

class Article extends Model
{
    /**
     * 获取所有针对文章的评论。
     */
    public function comments()
    {
        return $this->morphMany('Comment', 'commentable');
    }
}

<?php
namespace app\index\model;

use think\Model;

class Book extends Model
{
    /**
     * 获取所有针对书籍的评论。
     */
    public function comments()
    {
        return $this->morphMany('Comment', 'commentable');
    }
}
```

`morphMany('关联模型名','多态字段信息','多态类型');`

**关联模型名**（必须）：关联的模型名称，可以使用模型名（如`Comment`）或者完整的命名空间模型名（如`app\index\model\Comment`）。

**多态字段信息**（可选）：支持两种方式定义 如果是字符串表示多态字段的前缀，多态字段使用 `多态前缀_type`和`多态前缀_id`，如果是数组，表示使用['多态类型字段名','多态ID字段名']，默认为当前的关联方法名作为字段前缀。

**多态类型**（可选）：当前模型对应的多态类型，默认为当前模型名，可以使用模型名（如`Article`）或者完整的命名空间模型名（如`app\index\model\Article`）。

```
<?php
namespace app\index\model;

use think\Model;

class Comment extends Model
{
    /**
     * 获取评论对应的多态模型。
     */
    public function commentable()
    {
        return $this->morphTo();
    }
}

//自定义字段
    public function commentable()
    {
        return $this->morphTo('commentable',[
        	'book'	=>	'app\index\model\Book',
            'post'	=>	'app\admin\model\Article',
        ]);
    }
```

`morphTo('多态字段信息',['多态类型别名']);`

**多态字段信息**（可选）：支持两种方式定义 如果是字符串表示多态字段的前缀，多态字段使用 `多态前缀_type`和`多态前缀_id`，如果是数组，表示使用['多态类型字段名','多态ID字段名']，默认为当前的关联方法名作为字段前缀
**多态类型别名**（可选）：数组方式定义.。

#### 获取多态关联

一旦你的数据表及模型被定义，则可以通过模型来访问关联。例如，若要访问某篇文章的所有评论，则可以简单的使用 `comments` 动态属性：

```
$article = Article::get(1);

foreach ($article->comments as $comment) {
    dump($comment);
}
```

```
$comment = Comment::get(1);
$commentable = $comment->commentable;
```

`Comment` 模型的 `commentable` 关联会返回 `Article` 或 `Book` 模型的对象实例，这取决于评论所属模型的类型。

### 多台一对一

多态一对一相比多态一对多关联的区别是动态的一对一关联，举个例子说有一个个人和团队表，而无论个人还是团队都有**一个头像（that's why 一对一）**需要保存但都会对应同一个头像表

```
member
	id - integer
    name - string
    
team
	id - integer
    name - string
    
avatar
	id - integer
    avatar - string
    imageable_id - integer
    imageable_type - string  
```

```
<?php
namespace app\index\model;

use think\Model;

class Member extends Model
{
    /**
     * 获取用户的头像
     */
    public function avatar()
    {
        return $this->morphOne('Avatar', 'imageable');
    }
}

<?php
namespace app\index\model;

use think\Model;

class Team extends Model
{
    /**
     * 获取团队的头像
     */
    public function avatar()
    {
        return $this->morphOne('Avatar', 'imageable');
    }
}
```

`morphOne('关联模型名','多态字段信息','多态类型');`

**关联模型名**（必须）：关联的模型名称，可以使用模型名（如`Member`）或者完整的命名空间模型名（如`app\index\model\Member`）。

**多态字段信息**（可选）：支持两种方式定义 如果是字符串表示多态字段的前缀，多态字段使用 `多态前缀_type`和`多态前缀_id`，如果是数组，表示使用['多态类型字段名','多态ID字段名']，默认为当前的关联方法名作为字段前缀。

**多态类型**（可选）：当前模型对应的多态类型，默认为当前模型名，可以使用模型名（如`Member`）或者完整的命名空间模型名（如`app\index\model\Member`）。

```
<?php
namespace app\index\model;

use think\Model;

class Avatar extends Model
{
    /**
     * 获取头像对应的多态模型。
     */
    public function imageable()
    {
        return $this->morphTo();
    }
}
```

## 动态属性

在获取动态属性`profile`的同时，模型会通过定义的关联方法去查询关联对象的数据并赋值给该动态属性，这是一种关联数据的“惰性加载”，只有真正访问关联属性的时候才会进行关联查询。

```php
// 查询模型数据
$user = User::find(1);
// 获取动态属性
dump($user->profile);
// 给关联模型属性赋值
$user->profile->phone = '1234567890';
// 保存关联模型数据
$user->profile->save();
```

## 关联预载入

联查询的预查询载入功能，主要解决了`N+1`次查询的问题，例如下面的查询如果有3个记录，会执行4次查询：

```
$list = User::all([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user->profile);
}
```

如果使用关联预查询功能，对于一对一关联来说，只有一次查询，对于一对多关联的话，就可以变成2次查询，有效提高性能。

```php
$list = User::with('profile')->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user->profile);
}
```

支持预载入多个关联，例如：

```php
$list = User::with('profile,book')->select([1,2,3]);
```

也可以支持嵌套预载入，例如：

```php
$list = User::with('profile.phone')->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的phone模型
    dump($user->profile->phone);
}

$list = User::with(['profile'=>['phone','job','img']])->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联
    dump($user->profile->phone);
    dump($user->profile->job);    
    dump($user->profile->img);    
}
```

可以在模型的get和all方法中使用预载入，和使用select方法是等效的：

```php
$list = User::all([1,2,3],'profile,book');
```

如果要指定属性查询，可以使用：

```php
$list = User::field('id,name')->with(['profile'=>function($query){$query->field('email,phone');}])->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的profile模型数据
    dump($user->profile);
}
```

关联预载入名称是关联方法名，从`V5.0.4+`版本开始，支持传入方法名的小写和下划线定义方式，例如如果关联方法名是`userProfile`和`userBook`的话：

```php
$list = User::with('userProfile,userBook')->select([1,2,3]);
```

等效于：

```php
$list = User::with('user_profile,user_book')->select([1,2,3]);
```

`V5.0.4+`版本开始一对一关联预载入支持两种方式：`JOIN`方式（一次查询）和`IN`方式（两次查询），如果要使用`IN`方式关联预载入，在关联定义方法中添加

```php
<?php
namespace app\index\model;

use think\Model;

class User extends Model
{
    public function profile()
    {
    	// 设置预载入查询方式为IN方式
        return $this->hasOne('Profile')->setEagerlyType(1);
    }
}
```

`V5.0.5+`版本开始，默认使用IN查询方式，如果需要改为JOIN查询方式，使用

```php
    	// 设置预载入查询方式为JOIN方式
        return $this->hasOne('Profile')->setEagerlyType(0);
```

### 延迟预载入（`V5.0.5+`）

有些情况下，需要根据查询出来的数据来决定是否需要使用关联预载入，当然关联查询本身就能解决这个问题，因为关联查询是惰性的，不过用预载入的理由也很明显，性能具有优势。

延迟预载入仅针对多个数据的查询，因为单个数据的查询用延迟预载入和关联惰性查询没有任何区别，所以不需要使用延迟预载入。

如果你的数据集查询返回的是数据集对象，可以使用调用数据集对象的`load`实现延迟预载入：

```php
// 查询数据集
$list = User::all([1,2,3]);
// 延迟预载入
$list->load('cards');
foreach($list as $user){
    // 获取用户关联的card模型数据
    dump($user->cards);
}
```

如果你的数据集查询返回的是数组，系统提供了一个`load_relation`助手函数可以完成同样的功能。

```php
// 查询数据集
$list = User::all([1,2,3]);
// 延迟预载入
$list = load_relation($list,'cards');
foreach($list as $user){
    // 获取用户关联的card模型数据
    dump($user->cards);
}
```

## 关联统计

```php
//统计用户的card
//关联统计功能会在模型的对象属性中自动添加一个以“关联方法名+_count”为名称的动态属性来保存相关的关联统计数据。
$list = User::withCount('cards')->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的card关联统计
    echo $user->cards_count;
}

$list = User::withCount(['cards'=>function($query){
    $query->where('status',1);
}])->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的card关联统计
    echo $user->cards_count;
}

$list = User::withCount(['cards'=>'card_count'])->select([1,2,3]);
foreach($list as $user){
    // 获取用户关联的card关联统计
    echo $user->card_count;
}
```

## 聚合模型

### think_user

| 字段名   | 描述   |
| -------- | ------ |
| id       | 主键   |
| name     | 用户名 |
| password | 密码   |
| nickname | 昵称   |

### think_profile

| 字段名   | 描述     |
| -------- | -------- |
| id       | 主键     |
| truename | 真实姓名 |
| phone    | 电话     |
| email    | 邮箱     |
| user_id  | 用户ID   |

```php
namespace app\index\model;

use think\model\Merge;

class User extends Merge
{
    // 设置主表名
    protected $table = 'think_user';
    // 定义关联模型列表
    protected static $relationModel = [
        // 给关联模型设置数据表，（如果需要单独设置关联数据表）
        'Profile'   =>  'think_user_profile',
    ];
    // 定义关联外键
    protected $fk = 'user_id';
    protected $mapFields = [
        // 为混淆字段定义映射
        'id'        =>  'User.id',
        'profile_id' =>  'Profile.id',
    ];
}

// 关联查询
$user = User::get(1);
echo $user->id;
echo $user->name;
echo $user->phone;
echo $user->email;
echo $user->profile_id;
$user->email = 'thinkphp@qq.com';
// 关联保存
$user->save();
// 关联删除
$user->delete();
// 根据主键关联删除
User::destroy([1,2,3]);
```

一对多

```php
namespace app\index\model;
use think\model\Merge;

class User extends Merge
{
    // 定义关联模型列表
    protected static $relationModel = ['Profile'];
    // 定义关联外键
    protected $fk = 'user_id';
    protected $mapFields = [
        // 为混淆字段定义映射
        'id'        =>  'User.id',
        'profile_id' =>  'Profile.id',
    ];
    
    public function articles(){
        return $this->hasMany('Article');
    }
}

$user = User::get(1);
// 读取关联信息
dump($user->articles);
// 或者进行关联预载入
$user = User::get(1,'articles');
```

# 视图

## 视图实例化

视图功能由`\think\View`类配合视图驱动（模板引擎）类一起完成，目前的内置模板引擎包含PHP原生模板和Think模板引擎。

###继承`\think\Controller`类

如果你的控制器继承了`\think\Controller`类的话，则无需自己实例化视图类，可以直接调用控制器基础类封装的相关视图类的方法。

```
 // 渲染模板输出
return $this->fetch('hello',['name'=>'thinkphp']);
```

下面的方法可以直接被调用：

| 方法    | 说明           |
| ------- | -------------- |
| fetch   | 渲染模板输出   |
| display | 渲染内容输出   |
| assign  | 模板变量赋值   |
| engine  | 初始化模板引擎 |

## 助手函数

如果你只是需要渲染模板输出的话，可以使用系统提供的助手函数`view`，可以完成相同的功能：

```
return view('hello',['name'=>'thinkphp']);
```

`view('[模板文件]'[,'模板变量（数组）'][,模板替换（数组）])`

## 模板引擎

```
'template'               => [
    // 模板引擎类型 支持 php think 支持扩展
    'type'         => 'Think',
    // 模板路径
    'view_path'    => './template/',
    // 模板后缀
    'view_suffix'  => 'html',
    // 模板文件名分隔符
    'view_depr'    => DS,
    // 模板引擎普通标签开始标记
    'tpl_begin'    => '{',
    // 模板引擎普通标签结束标记
    'tpl_end'      => '}',
    // 标签库标签开始标记
    'taglib_begin' => '{',
    // 标签库标签结束标记
    'taglib_end'   => '}',
],
```

视图类也提供了`engine`方法对模板解析引擎进行初始化或者切换不同的模板引擎，例如：

```
return $this->engine('php')->fetch();
```

官方扩展库中提供了一个类似于`angularjs`语法的模板引擎`think-angular`，具体可以参考[参考手册](http://www.kancloud.cn/shuai/php-angular)。

## 模板赋值

```php
    public function index()
    {
        // 模板变量赋值
        $this->assign('name','ThinkPHP');
        $this->assign('email','thinkphp@qq.com');
        // 或者批量赋值
        $this->assign([
            'name'  => 'ThinkPHP',
            'email' => 'thinkphp@qq.com'
        ]);
        // 模板输出
        return $this->fetch('index');
    }
    
    //或者
        public function index()
    {
        return $this->fetch('index', [
            'name'  => 'ThinkPHP',
            'email' => 'thinkphp@qq.com'
        ]);
    }
    public function index()
    {
        $content = '{$name}-{$email}';
        return $this->display($content, [
            'name'  => 'ThinkPHP',
            'email' => 'thinkphp@qq.com'
        ]);
    }

//助手函数
return view('index', [
    'name'  => 'ThinkPHP',
    'email' => 'thinkphp@qq.com'
]);
```

## 模板渲染

`fetch('[模板文件]'[,'模板变量（数组）'])`

| 用法                   | 描述                                     |
| ---------------------- | ---------------------------------------- |
| 不带任何参数           | 自动定位当前操作的模板文件               |
| [模块@][控制器/][操作] | 常用写法，支持跨模块                     |
| 完整的模板文件名       | 直接使用完整的模板文件名（包括模板后缀） |

```
// 不带任何参数 自动定位当前操作的模板文件
return $this->fetch();

当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html

// 指定模板输出
return $this->fetch('edit'); 
// 表示调用Member控制器下面的read模板。
return $this->fetch('member/read');
//夸模块
return $this->fetch('admin@member/edit');

//V5.0.4+版本开始，支持从视图根目录开始读取模板，例如：
$this->fetch('/menu');
```

如果有更改模板引擎的`view_depr`设置（假设 `'view_depr'=>'_'`）的话，则上面的自动定位规则变成：

```
当前模块/默认视图目录/当前控制器（小写）_当前操作（小写）.html
```

## 输出替换

```php
namespace index\app\controller;

class Index extends \think\Controller
{
    public function index()
    {
        $this->assign('name','thinkphp');
        return $this->fetch('index',[],['__PUBLIC__'=>'/public/']);
    }
}
```

如果需要全局替换的话，可以直接在配置文件中添加：

```
'view_replace_str'  =>  [
    '__PUBLIC__'=>'/public/',
    '__ROOT__' => '/',
]
```

#模板

pass

# 日志

## 初始化

日志记录由`\think\Log`类完成，主要完成日志记录和跟踪调试。由于日志记录了所有的运行错误，因此养成经常查看日志文件的习惯，可以避免和及早发现很多的错误隐患。

```
Log::init([
    'type'  =>  'File',
    'path'  =>  APP_PATH.'logs/'
]);
```

## 日志驱动

```
'log'   => [
    // 可以临时关闭日志写入
    'type'  => 'test',
],

'log'   => [
    // 日志记录方式，支持 file socket
    'type' => 'File',
    //日志保存目录
    'path' => LOG_PATH,
    //单个日志文件的大小限制，超过后会自动记录到第二个文件
    'file_size'     =>2097152,
    //日志的时间格式，默认是` c `
    'time_format'   =>'c'
],
```

## 日志写入

| 方法          | 描述                                             |
| ------------- | ------------------------------------------------ |
| Log::record() | 记录日志信息到内存                               |
| Log::save()   | 把保存在内存中的日志信息（用指定的记录方式）写入 |
| Log::write()  | 实时写入一条日志信息                             |

由于系统在请求结束后会自动调用`Log::save`方法，所以通常，你只需要调用`Log::record`记录日志信息即可。

record方法用法如下：

```
Log::record('测试日志信息');
```

默认的话记录的日志级别是INFO，也可以指定日志级别：

```
Log::record('测试日志信息，这是警告级别','notice');
```

- **log** 常规日志，用于记录日志
- **error** 错误，一般会导致程序的终止
- **notice** 警告，程序可以运行但是还不够完美的错误
- **info** 信息，程序输出信息
- **debug** 调试，用于调试信息
- **sql** SQL语句，用于SQL记录，只在数据库的调试模式开启时有效

```
Log::error('错误信息');
Log::info('日志信息');
// 和下面的用法等效
Log::record('错误信息','error');
Log::record('日志信息','info');

trace('错误信息','error');
trace('日志信息','info');

'log'   => [
    'type'  => 'File',
    // 日志记录级别，使用数组表示
    'level' => ['error'],
    //清理
    'max_files'	=> 30,
    //单文件
    'single' => true,
    //独立日志类型
    'apart_level'   =>  ['error','sql'],
        // 授权只有202.12.36.89 才能记录日志
    'allow_key' =>  ['202.12.36.89'],

],
```

# 错误与调试

```
// 关闭调试模式
'app_debug' => false,
```

## 异常捕获

在异常捕获中不要使用`think\Controller`类的error、success和redirect方法，因为上述三个方法会抛出`HttpResponseException`异常，从而影响正常的异常捕获，例如：

```
try{
    Db::name('user')->find();
    $this->success('执行成功!');
}catch(\Exception $e){
    $this->error('执行错误');
}
```

应该改成

```
try{
    Db::name('user')->find();
}catch(\Exception $e){
    $this->error('执行错误');
}
$this->success('执行成功!');
```

## 抛出异常

```php
exception('异常消息', 100006);

// 使用自定义异常类
exception('异常消息', 100006, \foobar\Exceeption);

//HTTP异常
abort(404, '异常消息', [参数])
```

## Trace调试

```
// 开启应用Trace调试
'app_trace' =>  true,


// Trace信息
'trace'     =>  [
    //支持Html,Console
    'type'  =>  'html',
        // 使用浏览器console输出trace信息
    'type'  =>  'console',
] 
```

## 性能调试

https://www.kancloud.cn/manual/thinkphp5/126078

## SQL调试

可以查看执行的SQL语句

https://www.kancloud.cn/manual/thinkphp5/126079

## 404

```
'http_exception_template'    =>  [
    // 定义404错误的重定向页面地址
    404 =>  APP_PATH.'404.html',
    // 还可以定义其它的HTTP status
    401 =>  APP_PATH.'401.html',
]

abort(404,'页面不存在');
```

#验证

pass

